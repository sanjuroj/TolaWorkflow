{"version":3,"file":"results_framework-dd3261692d5dc54004dd.js","sources":["webpack:///./js/pages/results_framework/components/leveltier_picker.js","webpack:///./js/components/helpPopover.js","webpack:///./js/pages/results_framework/components/level_cards.js","webpack:///./js/components/selectWidgets.js","webpack:///./js/pages/results_framework/models.js","webpack:///./js/formUtils.js","webpack:///./js/pages/results_framework/index.js","webpack:///./js/general_utilities.js","webpack:///./js/api.js","webpack:///./js/components/indicatorModalComponents.js","webpack:///./js/eventbus.js","webpack:///./js/pages/results_framework/components/level_list.js","webpack:///./js/constants.js"],"sourcesContent":["import React from 'react';\nimport { observer, inject } from \"mobx-react\";\nimport { toJS } from \"mobx\";\n\nimport Select from 'react-select';\n\n@inject('rootStore')\n@observer\nclass Picker extends React.Component {\n    handleChange = selectedTemplate => {\n        this.props.rootStore.levelStore.changeTierSet(selectedTemplate.value);\n    };\n\n    componentDidUpdate() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    render() {\n        let helpIcon = null;\n        if (this.props.rootStore.uiStore.tierLockStatus == \"locked\"){\n\n            helpIcon = <a href=\"#\"\n                tabIndex=\"0\"\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-content={gettext('<span class=\"text-danger\"><strong>The results framework template cannot be changed after levels are saved.</strong></span> To change templates, all saved levels first must be deleted.  A level can be deleted when it has no sub-levels and no linked indicators.')}>\n                <i className=\"far fa-question-circle\"></i></a>\n        }\n        else if (this.props.rootStore.uiStore.tierLockStatus == \"primed\"){\n            helpIcon = <a href=\"#\"\n                tabIndex=\"0\"\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-content={gettext('<span class=\"text-danger\"><strong>Choose your results framework template carefully!</strong></span> Once you begin building your framework, it will not be possible to change templates without first deleting all saved levels.')}>\n                <i className=\"far fa-question-circle\"></i></a>\n        }\n\n\n        const tierTemplates = this.props.rootStore.levelStore.tierTemplates;\n\n        const options = Object.keys(tierTemplates).sort().map(key => {\n            return {value:key, label:tierTemplates[key]['name']};\n        });\n\n        const selectedOption = {value:this.props.rootStore.levelStore.chosenTierSetKey, label: this.props.rootStore.levelStore.chosenTierSetName};\n\n        let classes = \"leveltier-picker__selectbox \";\n        classes += this.props.rootStore.uiStore.tierLockStatus == \"locked\" ? \"leveltier-picker__selectbox--disabled\" : \"\";\n\n        return (\n              <div className={classes}>\n                  <div className=\"form-group\">\n                    <label>{gettext('Results framework template')}</label>&nbsp;<small>{helpIcon}</small>\n                    <Select\n                        options={options}\n                        value={selectedOption}\n                        isDisabled={this.props.rootStore.uiStore.tierLockStatus == \"locked\" ? true : false}\n                        onChange={this.handleChange}\n                    />\n                </div>\n            </div>\n        )\n    }\n}\n\nclass LevelTier extends React.Component {\n\n    render() {\n        return (\n            <div className={'leveltier leveltier--level-' + this.props.tierLevel}>{this.props.tierName} </div>\n    )}\n}\n\n@inject('rootStore')\n@observer\nclass LevelTierList extends React.Component{\n\n    render() {\n        let apply_button = null\n        if (this.props.rootStore.levelStore.levels.length == 0) {\n            apply_button =\n                <button\n                    className=\"leveltier-button btn btn-primary btn-block\"\n                    onClick={this.props.rootStore.levelStore.createFirstLevel}>\n                    {/* #Translators: this refers to an imperative verb on a button (\"Apply filters\")*/}\n                    {gettext(\"Apply\")}\n                </button>\n        }\n\n        return (\n            <React.Fragment>\n                <div id=\"leveltier-list\" className=\"leveltier-list\">\n                    {\n                        this.props.rootStore.levelStore.chosenTierSet.length > 0 ?\n                            this.props.rootStore.levelStore.chosenTierSet.map((tier, index) => {\n                                return <LevelTier key={index} tierLevel={index} tierName={tier}/>\n                            })\n                            : null\n                    }\n\n\n                </div>\n                {\n                    apply_button ?\n                        <div className=\"leveltier-list__actions\">\n                            {apply_button}\n                        </div>\n                    : null\n                }\n            </React.Fragment>\n        )\n    }\n}\n\nconst ChangeLogLink = ({programId}) => {\n    const url = `/tola_management/audit_log/${programId}/`;\n\n    return <div className=\"leveltier-picker__change-log-link-box\">\n        <a href={url} className=\"btn-link\">\n            <i className=\"fas fa-history\" /> {gettext('Change log')}\n        </a>\n    </div>\n}\n\nexport const LevelTierPicker = inject(\"rootStore\")(observer(function (props) {\n\n    return (\n        <div id=\"leveltier-picker\" className=\"leveltier-picker\">\n            <div className=\"leveltier-picker__panel\">\n                <Picker />\n                <LevelTierList />\n            </div>\n\n            <ChangeLogLink programId={props.rootStore.levelStore.program_id} />\n        </div>\n        /*<div id=\"alerts2\" style={{minHeight:\"50px\", minWidth:\"50px\", backgroundColor:\"red\"}}></div>*/\n\n    )\n}));\n","import React from 'react'\nimport ReactDOM from 'react-dom';\n\nexport default class HelpPopover extends React.Component {\n    constructor(props) {\n        super(props)\n        this.content = props.content;\n        this.placement = props.placement || null;\n    }\n\n    render() {\n        return (\n            <a\n                tabIndex=\"0\"\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-placement={this.placement}\n                data-content={this.content}>\n            <i className=\"far fa-question-circle\"></i></a>\n        )\n    }\n}\n\n\nexport class BootstrapPopoverButton extends React.Component {\n    popoverName = 'base';\n\n    componentDidMount = () => {\n        // make a cancelable (class method) function so clicking out of the popover will close it:\n        this.bodyClickHandler = (ev) => {\n            if ($(`#${this.popoverName}_popover_content`).parent().find($(ev.target)).length == 0) {\n                $(this.refs.target).popover('hide');\n            }\n        }\n        const popoverOpenHandler = () => {\n            // first make it so any click outside of the popover will hide it:\n            $('body').on('click', this.bodyClickHandler);\n            // update position (it's had content loaded):\n            $(this.refs.target).popover('update')\n                //when it hides destroy the body clickhandler:\n                .on('hide.bs.popover', () => {$('body').off('click', this.bodyClickHandler);});\n        };\n        const shownFn = (ev) => {\n            ReactDOM.render(\n                this.getPopoverContent(),\n                document.querySelector(`#${this.popoverName}_popover_content`),\n                popoverOpenHandler\n            );\n        };\n        $(this.refs.target).popover({\n            content: `<div id=\"${this.popoverName}_popover_content\"></div>`,\n            html: true,\n            placement: 'bottom'\n        }).on('shown.bs.popover', shownFn);\n    }\n    \n    getPopoverContent = () => {\n        throw new Error('not implemented');\n    }\n}","import React from 'react';\nimport classNames from 'classnames';\nimport { observer, inject } from \"mobx-react\"\nimport { toJS, extendObservable, action } from 'mobx';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faCaretRight, faCaretDown, faArrowsAlt } from '@fortawesome/free-solid-svg-icons'\nimport { SingleReactSelect } from \"../../../components/selectWidgets\";\nimport { AddIndicatorButton, UpdateIndicatorButton } from '../../../components/indicatorModalComponents';\nimport {sortableContainer, sortableElement, sortableHandle} from 'react-sortable-hoc';\nimport HelpPopover from \"../../../components/helpPopover\";\nimport TextareaAutosize from 'react-autosize-textarea';\nimport Select from \"react-select\"\n\n\n\nlibrary.add(faCaretDown, faCaretRight, faArrowsAlt);\n\nexport class LevelTitle extends React.Component {\n\n    render() {\n        return (\n            <h3 className={'level-title ' + this.props.classes}>\n                {this.props.tierName}\n                {/*if we don't check whether there is an ontology, there ill be an extra\n                space before the colon */}\n                {this.props.ontologyLabel ? \" \" + this.props.ontologyLabel : null}\n            </h3>\n        )\n    }\n}\n\nclass ProgramObjectiveImport extends React.Component {\n    onChange = (item) => {\n        this.props.onProgramObjectiveImport(item.value);\n    }\n\n    render() {\n        const programObjectives = this.props.programObjectives;\n\n        // hide if no objectives to import\n        if (programObjectives.length === 0) return null;\n\n        const options = programObjectives.map( entry => {return {value: entry.id, label: entry.name}});\n\n        return (\n            <div className=\"program-objective-import mb-3\">\n                <Select\n                    // # Translators: Take the text of a program objective and import it for editing\n                    placeholder={gettext('Import Program Objective')}\n                    onChange={ this.onChange }\n                    value={ \"\" }\n                    className=\"tola-react-select\"\n                    options={ options }\n                    isDisabled={this.props.isDisabled}\n                />\n\n                <a href=\"#\"\n                   className=\"program-objective-import__icon\"\n                   tabIndex=\"0\"\n                   data-html=\"true\"\n                   data-toggle=\"popover\"\n                   data-placement=\"bottom\"\n                   data-trigger=\"focus\"\n                   data-content={\n                       /* # Translators: instructions to users containing some HTML */\n                       gettext(\"Import text from a Program Objective. <strong class='program-objective-import__popover-strong-text'>Make sure to remove levels and numbers from your text, because they are automatically displayed.</strong>\")\n                   }\n                   onClick={e => e.preventDefault()}>\n                    <i className=\"far fa-question-circle\"/>\n                </a>\n            </div>\n        )\n    }\n}\n\n@inject('rootStore')\n@observer\nexport class LevelCardCollapsed extends React.Component {\n\n    deleteLevel = () => {\n        this.props.rootStore.uiStore.setDisableForPrompt(true);\n        const levelTitle = this.props.levelProps.tierName + \" \" + this.props.levelProps.ontologyLabel;\n        create_no_rationale_changeset_notice({\n            /* # Translators:  This is a confirmation prompt that is triggered by clicking on a delete button. The code is a reference to the name of the specific item being deleted.  Only one item can be deleted at a time. */\n            message_text: interpolate(gettext(\"Are you sure you want to delete %s?\"), [levelTitle]),\n            on_submit: () => this.props.rootStore.levelStore.deleteLevelFromDB(this.props.level.id),\n            on_cancel: () => this.props.rootStore.uiStore.setDisableForPrompt(false)\n        })\n    };\n\n    editLevel = () => {\n        this.props.rootStore.uiStore.editCard(this.props.level.id)\n    };\n\n    componentDidMount() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    buildIPTTUrl = (indicator_ids) => {\n        let url = `/indicators/iptt_report/${this.props.rootStore.levelStore.program_id}/timeperiods/?frequency=3&start=0&end=999`;\n        indicator_ids.forEach( i => url += \"&indicators=\"+i);\n        return url\n    };\n\n    render(){\n        // the level card shouldn't be displayed if it's parent level is not expandoed (except\n        // if the level is the top level one).\n        if (this.props.rootStore.uiStore.hasVisibleChildren.indexOf(this.props.level.parent) < 0 && this.props.level.parent != null){\n            return null;\n        }\n\n        // Prepare the indicator links for the indicator popover\n        let allIndicatorLinks = [];\n\n        // Get indicator ids linked to this level and create a hyperlink for a filtered IPTT.\n        let sameLevelIndicatorIds = this.props.levelProps.indicators.map( i => i.id);\n        if (sameLevelIndicatorIds.length > 0) {\n            const linkText = `All indicators linked to ${this.props.levelProps.tierName} ${this.props.levelProps.ontologyLabel}`\n            allIndicatorLinks.push(`<li class=\"nav-item level-card--iptt-links\"><a href=${this.buildIPTTUrl(sameLevelIndicatorIds)}>${linkText}</a></li>`);\n        }\n\n        // Get indicator ids linked to the descendants of this level, add the indicator ids identified\n        // above, and create a hyperlink for a filtered IPTT.  Only do this if the level has sublevels.\n        if (this.props.levelProps.tierName != this.props.rootStore.levelStore.chosenTierSet.slice(-1)[0]) {\n            let descendantIndicatorIds = this.props.levelProps.descendantIndicatorIds;\n            descendantIndicatorIds = descendantIndicatorIds.concat(sameLevelIndicatorIds);\n            if (descendantIndicatorIds.length > 0) {\n                const linkText = `All indicators linked to ${this.props.levelProps.tierName} ${this.props.levelProps.ontologyLabel} and sub-levels`;\n                allIndicatorLinks.unshift(`<li class=\"nav-item level-card--iptt-links\"><a href=${this.buildIPTTUrl(descendantIndicatorIds)}>${linkText}</a></li>`);\n            }\n        }\n\n        // Create IPTT hyperlinks for each individual indicator linked to this level\n        let individualLinks = this.props.levelProps.indicators\n            .sort( (a, b) => a.level_order - b.level_order)\n            .map( (indicator, index) => {\n                let indicatorNumber = \"\";\n                if (!this.props.rootStore.levelStore.manual_numbering) {\n                    indicatorNumber = this.props.levelProps.ontologyLabel + String.fromCharCode(97 + index) + \": \";\n                }\n                else if (this.props.rootStore.levelStore.manual_numbering && indicator.number) {\n                    indicatorNumber = indicator.number + \": \";\n                }\n                return `<li class=\"nav-item level-card--iptt-links\"><a href=${this.buildIPTTUrl([indicator.id])}>${indicatorNumber}${indicator.name}</a></li>`;\n            });\n\n        allIndicatorLinks = allIndicatorLinks.concat(individualLinks);\n\n\n        let indicatorMarkup = `<ul class=\"nav flex-column\">${allIndicatorLinks.join(\"\")}</ul>`;\n        const iCount = this.props.levelProps.indicators.length;\n        /* # Translators: This is a count of indicators associated with another object */\n        const indicatorCountText = interpolate(ngettext(\"%s indicator\", \"%s indicators\", iCount), [iCount]);\n\n        // The expando caret is only applied to levels that:\n        // 1. Aren't at the end of the leveltier hierarchy\n        // 2. Actually have children\n        let expando = null;\n        if (this.props.levelProps.tierName != toJS(this.props.rootStore.levelStore.chosenTierSet.slice(-1)[0]) &&\n            this.props.rootStore.levelStore.levels.filter( l => l.parent == this.props.level.id).length > 0){\n            expando = <FontAwesomeIcon className=\"text-action\" icon={this.props.rootStore.uiStore.hasVisibleChildren.indexOf(this.props.level.id) >= 0 ? 'caret-down' : 'caret-right'} />\n        }\n\n        let isDisabled = allIndicatorLinks.length == 0 || this.props.rootStore.uiStore.disableForPrompt;\n        return (\n            <div className=\"level-card level-card--collapsed\" id={`level-card-${this.props.level.id}`}>\n                <div\n                    className={expando ? \"level-card__toggle\": \"\"}\n                    onClick={(e) => this.props.rootStore.uiStore.updateVisibleChildren(this.props.level.id)}>\n                    {expando}\n                    <span className=\"level-card--collapsed__name\">\n                        <LevelTitle\n                            tierName={this.props.levelProps.tierName}\n                            ontologyLabel={this.props.levelProps.ontologyLabel}\n                            classes=\"level-title--collapsed\"\n                        />\n                        &nbsp;{this.props.level.name}\n                    </span>\n                </div>\n                <div className=\"level-card--collapsed__actions\">\n                    <div className=\"actions__top btn-row\">\n                        { this.props.levelProps.canDelete &&\n                            <button\n                                disabled={this.props.rootStore.uiStore.disableForPrompt || this.props.rootStore.uiStore.activeCard}\n                                className=\"btn btn-sm btn-link btn-danger\"\n                                onClick={this.deleteLevel}>\n                                <i className=\"fas fa-trash-alt\"></i>{gettext(\"Delete\")}\n                            </button>\n                        }\n                        {this.props.levelProps.canEdit &&\n                            <button\n                                disabled={this.props.rootStore.uiStore.disableForPrompt}\n                                className=\"btn btn-sm btn-link btn-text edit-button\"\n                                onClick={this.editLevel}>\n                                <i className=\"fas fa-edit\"/>{gettext(\"Edit\")}\n                            </button>\n                        }\n                    </div>\n                    <div className=\"actions__bottom\">\n                        <a\n                            tabIndex=\"0\"\n                            className={classNames(\"btn btn-sm btn-link no-bold\", {disabled: isDisabled})}\n                            data-toggle=\"popover\"\n                            data-trigger=\"focus\"\n                            data-placement=\"bottom\"\n                            data-html=\"true\"\n                            title=\"Track indicator performance\"\n                            data-content={indicatorMarkup}>\n                            {indicatorCountText}\n                        </a>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\n\n@inject('rootStore')\n@observer\nexport class LevelCardExpanded extends React.Component {\n    constructor(props){\n        super(props);\n        this.submitType = \"saveOnly\";\n        this.indicatorWasReordered = false;\n\n        // These 'base' vars will allow us to save orignalish data so we know whether to prompt users if they hit cancel.\n        // baseIndicators will need to be updated on indicator changes other than reordering since we don't\n        // want to warn for e.g. indicator creation, since users can't do anything about that.\n        this.baseLevelString = JSON.stringify([props.level.name, props.level.assumptions]);\n        this.baseIndicators = this.props.levelProps.indicators.slice().map( i => toJS(i));\n\n        extendObservable(this, {\n            name: props.level.name,\n            assumptions: props.level.assumptions,\n            indicators: props.levelProps.indicators.sort((a, b) => a.level_order - b.level_order),\n\n            get dataHasChanged () {\n                const baseData = this.baseLevelString + JSON.stringify(this.baseIndicators.sort( (a, b) => a.id - b.id));\n                const currentData = JSON.stringify([this.name, this.assumptions]) + JSON.stringify(toJS(this.indicators).sort( (a, b) => a.id - b.id));\n                return currentData != baseData;\n            },\n\n            addIndicator (data) {\n                this.indicators.push(data);\n                this.baseIndicators.push(data)\n            },\n\n            deleteIndicator (indicatorId) {\n                this.indicators = this.indicators.filter( i => i.id != indicatorId);\n                this.indicators.forEach( (indicator, index) => indicator.level_order = index);\n                this.baseIndicators = this.baseIndicators.filter( i => i.id != indicatorId);\n                this.baseIndicators.forEach( (indicator, index) => indicator.level_order = index);\n            },\n\n            updateIndicatorName (indicatorId, newName) {\n                this.indicators.find( i => i.id == indicatorId).name = newName;\n                this.baseIndicators.find( i => i.id == indicatorId).name = newName;\n                this.props.rootStore.levelStore.updateIndicatorNameInStore(indicatorId, newName);\n            }\n\n        }, {\n            addIndicator: action,\n            deleteIndicator: action,\n            updateIndicatorName: action\n        });\n    }\n\n    onDragEnd = ({oldIndex, newIndex}) => {\n        this.indicatorWasReordered = true;\n        const indicatorId = this.indicators[oldIndex].id;\n        const fakeChangeObj = {value: newIndex + 1, name: newIndex + 1};\n        this.changeIndicatorOrder(indicatorId, fakeChangeObj)\n    };\n\n    // Updates the indicator order, resets level_order as necessary, sets updated data flag.\n    changeIndicatorOrder = (indicatorId, changeObj) => {\n        let oldIndex = this.indicators.find( i => i.id == indicatorId).level_order;\n        let newIndex = changeObj.value - 1;\n        let tempIndicators = this.indicators.slice();\n        tempIndicators.splice(newIndex, 0, tempIndicators.splice(oldIndex, 1)[0]);\n        tempIndicators.forEach( (indicator, index) => indicator.level_order = index);\n        this.indicators.replace(tempIndicators)\n        this.props.rootStore.uiStore.activeCardNeedsConfirm = this.dataHasChanged;\n        this.indicatorWasReordered = true;\n    };\n\n    /*\n    Using this allows us to use the same submit function for all three buttons.  Shame the function has to\n    be passed all the way down to the button to work.\n     */\n    updateSubmitType = (newType) => {\n        this.submitType = newType;\n    };\n\n    componentDidUpdate() {\n        // Enable popovers after update.  This is needed for the help popover in the indicator list section.\n        // Without this, the popover doesnt' pop.\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n    }\n\n    componentDidMount() {\n        // Enable popovers after load (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n\n        // Handle indicator creation.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('created.tola.indicator.save', (e, params) => {\n            const indicatorData = {\n                id: params.indicatorId,\n                name: params.indicatorName,\n                level: this.props.level.id,\n                level_order: this.indicators.length\n            };\n            this.props.rootStore.levelStore.addIndicatorToStore(indicatorData)\n            this.addIndicator(indicatorData)\n\n        });\n\n        // Handle indicator deletion.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('deleted.tola.indicator.save', (e, params) => {\n            this.props.rootStore.levelStore.deleteIndicatorFromStore(params.indicatorId);\n            this.deleteIndicator(params.indicatorId)\n\n        });\n\n        // Handle indicator update.  Need to update rootStore and component store so if you close and reopen the card, you still see the new indicator\n        $('#indicator_modal_div').on('updated.tola.indicator.save', (e, params) => {\n\n            this.updateIndicatorName(params.indicatorId, params.indicatorName);\n\n            if (params.levelId != this.props.rootStore.uiStore.activeCard){\n                // Only add the indicator to another level if it wasn't blanked out\n                if (params.levelId){\n                    this.props.rootStore.levelStore.moveIndicatorInStore(params.indicatorId, params.levelId)\n                }\n                this.deleteIndicator(params.indicatorId);\n            }\n\n            // Need to remount the tooltip so it reflects a potential new name.  It's a big janky, should probably use a react component instead.\n            $('*[data-toggle=\"tooltip\"]').tooltip('dispose');\n            $('*[data-toggle=\"tooltip\"]').tooltip();\n        });\n    }\n\n    componentWillUnmount() {\n        $('#indicator_modal_div').off('updated.tola.indicator.save');\n        $('#indicator_modal_div').off('deleted.tola.indicator.save');\n        $('#indicator_modal_div').off('created.tola.indicator.save');\n    }\n\n    saveLevel = (event) => {\n        event.preventDefault();\n        const saveFunc = (rationale) => {\n            this.props.rootStore.levelStore.saveLevelToDB(\n                this.submitType,\n                this.props.level.id,\n                this.indicatorWasReordered,\n                {\n                    name: this.name,\n                    assumptions: this.assumptions,\n                    rationale: rationale,\n                    indicators: toJS(this.indicators)}\n            )};\n\n        const hasIndicators = this.indicators.length > 0;\n        const hasUpdatedAssumptions = this.props.level.assumptions.length > 0 && this.assumptions != this.props.level.assumptions;\n        const hasUpdatedName = this.name != this.props.level.name;\n\n        if ( hasIndicators && (hasUpdatedAssumptions || hasUpdatedName)){\n            create_nondestructive_changeset_notice({\n                on_submit: saveFunc,\n                on_cancel: () => this.props.rootStore.uiStore.setDisableForPrompt(false),\n            });\n        }\n        else {\n            saveFunc('');\n        }\n    };\n\n    cancelEdit = () => {\n        if (this.props.rootStore.levelStore.levels.length == 1 && this.props.level.id == \"new\"){\n            this.clearData();\n        }\n        else{\n            this.props.rootStore.levelStore.cancelEdit(this.props.level.id);\n        }\n    };\n\n    clearData = () => {\n        this.name = \"\";\n        this.assumptions = \"\";\n    };\n\n    onFormChange = (event) => {\n        event.preventDefault();\n        this[event.target.name] = event.target.value;\n        // Add inline error message if name field is blanked out\n        if (!this.name) {\n            const target = $(`#level-name-${this.props.level.id}`);\n            target.addClass(\"is-invalid\");\n            /* # Translators: This is a validation message given to the user when the user-editable name field has been deleted or omitted. */\n            let feedbackText = gettext('Please complete this field.');\n            target.after(`<p id=name-feedback-${this.props.level.id} class=\"invalid-feedback\">${feedbackText}</p>`);\n        }\n        else{\n            $(`#level-name-${this.props.level.id}`).removeClass(\"is-invalid\");\n            $(`#name-feedback-${this.props.level.id}`).remove();\n        }\n        this.props.rootStore.uiStore.activeCardNeedsConfirm = this.dataHasChanged;\n    };\n\n    onProgramObjectiveImport = (programObjectiveId) => {\n        const programObjective = this.props.rootStore.levelStore.programObjectives.find(po => po.id === programObjectiveId);\n\n        if (programObjective != null) {\n            this.name = programObjective.name;\n            this.assumptions = programObjective.description;\n        }\n    };\n\n    render(){\n        // Need to reference a couple of observed vars so they react to changes.\n        // Simply passing the observables through to a child component or injecting them in\n        // the child component doesn't work.  No doubt that there's a better way to do this.\n        const tempIndicators = toJS(this.indicators);\n        const disabledTrigger = this.props.rootStore.uiStore.disableForPrompt;\n        const programObjectives = this.props.rootStore.levelStore.programObjectives;\n\n        let indicatorSection = \"\";\n        if (this.props.level.id == \"new\"){\n            indicatorSection = <div className=\"form-group\">\n                <button\n                    type=\"submit\"\n                    disabled={this.name.length > 0 ? false : true}\n                    className=\"btn btn-link btn-lg \"\n                    onClick={e => {this.updateSubmitType(\"saveAndEnableIndicators\")}}>\n                        { /* # Translators: This is button text that allows users to save their work and unlock the ability to add indicators */ }\n                        <i className=\"fas fa-plus-circle\"/>{interpolate(gettext(\"Save %s and add indicators\"), [this.props.levelProps.tierName])}\n                </button>\n            </div>\n\n        }\n        else {\n            indicatorSection = <IndicatorList\n                level={this.props.level}\n                tierName={this.props.levelProps.tierName}\n                indicators={this.indicators}\n                disabled={!this.name || this.props.level.id == \"new\" || this.props.rootStore.uiStore.disableForPrompt}\n                reorderDisabled={this.indicators.length < 2 || this.props.rootStore.uiStore.disableForPrompt}\n                changeFunc={this.changeIndicatorOrder}\n                dragEndFunc={this.onDragEnd}/>\n        }\n\n\n\n        return (\n            <div className=\"level-card level-card--expanded\" id={`level-card-${this.props.level.id}`}>\n                <div className=\"d-flex justify-content-between\">\n                    <LevelTitle\n                        tierName={this.props.levelProps.tierName}\n                        ontologyLabel={this.props.levelProps.ontologyLabel}\n                        classes=\"level-title--expanded\"\n                    />\n\n                    <ProgramObjectiveImport\n                        isDisabled = {this.props.rootStore.uiStore.disableForPrompt}\n                        programObjectives={programObjectives}\n                        onProgramObjectiveImport={this.onProgramObjectiveImport} />\n                </div>\n                <form className=\"level-card--expanded__form\" onSubmit={this.saveLevel}>\n                    <div className=\"form-group\">\n                        <TextareaAutosize\n                            className=\"form-control\"\n                            id={`level-name-${this.props.level.id}`}\n                            name=\"name\"\n                            value={this.name || \"\"}\n                            disabled={this.props.rootStore.uiStore.disableForPrompt}\n                            autoComplete=\"off\"\n                            rows={3}\n                            onChange={this.onFormChange}\n                            maxLength={500}\n                        />\n                    </div>\n                    <div className=\"form-group\">\n                        <label htmlFor=\"assumptions\">{gettext('Assumptions')}</label>\n                        <TextareaAutosize\n                            className=\"form-control\"\n                            id=\"level-assumptions\"\n                            disabled={!this.name || this.props.rootStore.uiStore.disableForPrompt}\n                            name=\"assumptions\"\n                            autoComplete=\"off\"\n                            value={this.assumptions || \"\"}\n                            rows={3}\n                            onChange={this.onFormChange}/>\n                    </div>\n                    {indicatorSection}\n                    <ButtonBar\n                        level={this.props.level}\n                        levelProps={this.props.levelProps}\n                        submitFunc={this.updateSubmitType}\n                        cancelFunc={this.cancelEdit}\n                        nameVal={this.name}\n                        tierCount={this.props.rootStore.levelStore.chosenTierSet.length}\n                    />\n                </form>\n            </div>\n\n        )\n    }\n}\n\n\n@inject('rootStore')\nclass ButtonBar extends React.Component {\n    render() {\n        let isDisabled = !this.props.nameVal || this.props.rootStore.uiStore.disableForPrompt;\n\n        // Build the button text with the right sibling level name, then build the button.\n        let addAnotherButton = null;\n        if (this.props.level.parent != null && this.props.level.parent != \"root\") {\n            {/* # Translators: On a button, with a tiered set of objects, save current object and add another one in the same tier, e.g. \"Save and add another Outcome\" when the user is editing an Outcome */}\n            const buttonText = interpolate(gettext(\"Save and add another %s\"), [this.props.levelProps.tierName])\n            addAnotherButton = <LevelButton disabled={isDisabled} classes=\"btn-primary\" icon='plus-circle' text={buttonText} submitType=\"saveAndAddSibling\"  submitFunc={this.props.submitFunc} />\n        }\n\n        // Build the button text with the right child level name, then build the button.\n        let addAndLinkButton = null;\n        const tierCount = this.props.rootStore.levelStore.chosenTierSet.length;\n        if (this.props.level.level_depth < tierCount) {\n            {/* # Translators: On a button, with a tiered set of objects, save current object and add another one in the next lower tier, e.g. \"Save and add another Activity\" when the user is editing a Goal */}\n            const buttonText = interpolate(gettext(\"Save and link %s\"), [this.props.levelProps.childTierName])\n            addAndLinkButton = <LevelButton disabled={isDisabled} classes=\"btn btn-primary\" icon='stream' text={buttonText} submitType=\"saveAndAddChild\" submitFunc={this.props.submitFunc} />\n        }\n        return (\n            <div className=\"button-bar btn-row\">\n                <LevelButton disabled={isDisabled} classes=\"btn-primary\" text={gettext(\"Save and close\")} icon='save' submitType=\"saveOnly\" submitFunc={this.props.submitFunc} />\n                {addAnotherButton}\n                {addAndLinkButton}\n                <LevelButton disabled={this.props.rootStore.uiStore.disableForPrompt} classes=\"btn btn-reset\" text={gettext(\"Cancel\")} submitType=\"cancel\" submitFunc={this.props.cancelFunc} />\n            </div>\n        )\n\n    }\n}\n\nclass LevelButton extends React.Component {\n\n    render() {\n        const buttonType = this.props.submitType == \"cancel\" ? \"button\" : \"submit\";\n        return (\n            <button\n                disabled={this.props.disabled}\n                type={buttonType}\n                className={this.props.classes + ' level-button btn btn-sm'}\n                onClick={() =>this.props.submitFunc(this.props.submitType)}>\n                {this.props.text}\n                {/*this.props.icon ?  <FontAwesomeIcon icon={this.props.icon} /> : ''*/}\n            </button>\n        )\n\n    }\n}\n\n@inject('rootStore')\nclass IndicatorList extends React.Component {\n\n    componentDidMount() {\n        // Enable popovers after update (they break otherwise)\n        $('*[data-toggle=\"popover\"]').popover({\n            html: true\n        });\n\n        $('*[data-toggle=\"tooltip\"]').tooltip()\n    }\n\n    componentDidUpdate() {\n        $('*[data-toggle=\"tooltip\"]').tooltip()\n    }\n\n    render() {\n\n        // Create the list of indicators and the dropdowns for setting the indicator order\n        let options = this.props.indicators.map( (entry, index) => {return {value: index+1, label: index+1}});\n\n        let indicatorMarkup = this.props.indicators.map ( (indicator) => {\n            // let options = this.props.indicators.map( (entry, index) => <option value={index+1}>{index+1}</option>);\n            const tipTemplate = '<div class=\"tooltip sortable-list__item__tooltip\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>';\n            const indicator_label =\n                <span data-toggle=\"tooltip\" data-delay={900} data-template={tipTemplate} title={indicator.name}>\n                    <span>{indicator.name.replace(/(.{55})..+/, \"$1...\")}</span>\n                </span>\n            return (\n                <React.Fragment>\n                    <SingleReactSelect\n                        update={(value) => this.props.changeFunc(indicator.id, value)}\n                        selectId={\"ind\"+indicator.id}\n                        labelClasses=\" \"\n                        formRowClasses=\"sortable-list__item__label\"\n                        selectClasses=\"sortable-list__item__select\"\n                        value={{value: indicator.level_order, label: indicator.level_order + 1}}\n                        label={indicator_label}\n                        options={options}\n                        disabled={this.props.disabled || this.props.reorderDisabled}\n                    />\n                    <div className=\"sortable-list__item__actions\">\n                        { /* # Translators: A label for a button that allows the user to modify the settings of an object */}\n                        <UpdateIndicatorButton\n                            readonly={this.props.disabled || this.props.rootStore.uiStore.disableForPrompt}\n                            label={gettext(\"Settings\")}\n                            indicatorId={indicator.id}/>\n                    </div>\n                </React.Fragment>\n            )\n        });\n\n        // Conditionally set the other elements that are only visible when there are indicators\n        let order = null;\n        let helpLink = null;\n        const migratedProgramPopOverContent =\n            /* # Translators: Popover for help link telling users how to associate an Indicator not yet linked to a Level */\n            gettext('To link an already saved indicator to your results framework: Open the indicator from the program page and use the “Result level” menu on the Summary tab.');\n        /* # Translators: Popover for help link, tell user how to disassociate an Indicator from the Level they are currently editing. */\n        const popOverContent=gettext('To remove an indicator: Click “Settings”, where you can reassign the indicator to a different level or delete it.');\n\n        const usingResultsFramework = this.props.rootStore.levelStore.usingResultsFramework;\n        const popOverStr = !usingResultsFramework ? migratedProgramPopOverContent + '<br><br>' + popOverContent : popOverContent;\n\n        if (this.props.indicators.length > 0 || !usingResultsFramework) {\n            order = \"Order\";\n            helpLink =\n                <HelpPopover\n                    content={popOverStr}\n                    placement=\"bottom\"/>\n        }\n        return(\n            <div className={`level-card--indicator-links${this.props.disabled ? \" disabled\" : \"\"}`}>\n                <div className=\"indicator-links__header\">\n                    { /* # Translators: Title for a section that lists the Indicators associated with whatever this.props.tiername is. */}\n                    <h4>{interpolate(gettext(\"Indicators linked to this %s\"), [this.props.tierName])}</h4>\n                    <div>{helpLink}</div>\n                </div>\n                <div className=\"sortable-list-group\">\n                    { this.props.indicators.length > 0 ?\n                        <div className=\"sortable-list-header\">\n                            { /* TODO: this header is super janky. See _sortable-list.scss for future proofing with css subgrid */ }\n                            <div className=\"sortable-list-header__drag-handle\"><FontAwesomeIcon icon={faArrowsAlt} /></div>\n                            <div className=\"sortable-list-header__label\">\n                                {order}\n                            </div>\n                            <div className=\"sortable-list-header__actions\">\n                                <i className=\"fas fa-cog\"></i> { gettext(\"Settings\") }\n                            </div>\n                        </div>\n                    :\n                        null\n                    }\n                    <SortableContainer onSortEnd={this.props.dragEndFunc} useDragHandle lockAxis=\"y\" lockToContainerEdges>\n                        {indicatorMarkup.map((value, index) => (\n                            <SortableItem\n                                key={`item-${index}`}\n                                index={index}\n                                value={value}\n                                disabled={this.props.disabled || this.props.reorderDisabled} />\n                        ))}\n                    </SortableContainer>\n                    <div className=\"sortable-list-actions\">\n                        <AddIndicatorButton\n                            readonly={ !this.props.level.id || this.props.level.id == 'new' || this.props.disabled || this.props.rootStore.uiStore.disableForPrompt }\n                            programId={ this.props.rootStore.levelStore.program_id }\n                            levelId={ this.props.level.id }/>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nconst SortableItem = sortableElement(({value}) => <li className=\"sortable-list__item\"><DragHandle/>{value}</li>);\n\nconst SortableContainer = sortableContainer(({children}) => {\n    return <ul className=\"sortable-list\">{children}</ul>;\n});\n\nconst DragHandle = sortableHandle(() => <div className=\"sortable-list__item__drag-handle\"><FontAwesomeIcon icon={faArrowsAlt} /></div>);\n","import React from 'react';\nimport Select from 'react-select';\nimport ReactMultiSelectCheckboxes from 'react-multiselect-checkboxes';\nimport { uniqueId } from '../formUtils';\nimport { GROUP_BY_CHAIN, GROUP_BY_LEVEL } from '../constants';\n\n\n\nexport const SingleReactSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let labelClasses = props.labelClasses || \"col-form-label text-uppercase\";\n    let formRowClasses = props.formRowClasses || \"form-row mb-3\";\n    let selectClasses = props.selectClasses || \"tola-react-select\";\n    return (\n        <div className={ formRowClasses }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClasses }>\n                    { props.label }\n            </label>\n            <Select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClasses }\n                isDisabled={ props.disabled }\n                options={ props.options }\n            />\n        </div>\n    );\n}\n\nexport const DateSelect = ( props ) => {\n    let selectId = uniqueId('date-select');\n    let formattedOptions =\n        (props.options && props.options.length == 1 && props.options[0].value !== undefined) ?\n            <option value={ props.options[0].value }>{ props.options[0].label }</option> :\n            (props.options && props.options.length > 0 && props.options[0].options && props.options[0].options !== undefined) ?\n                props.options.map(\n                    (optgroup, index) => {\n                        return <optgroup label={ optgroup.label } key={ index }>\n                                    {optgroup.options.map(\n                                        option => (<option value={ option.value } key={ option.value }>\n                                                        { option.label }\n                                                   </option>)\n                                        )\n                                    }\n                                </optgroup>\n                        }) :\n                props.options.map(\n                    (option, index) => {\n                        return <option value={ option.value } key={ index }>{ option.label }</option>;\n                    }\n                );\n\n    return (\n        <div className=\"form-row mb-3\">\n            <label\n                htmlFor={ selectId }\n                className=\"col-form-label text-uppercase\">\n                    { props.label }\n            </label>\n            <select\n                className=\"form-control\"\n                id={ selectId }\n                value={ props.value }\n                onChange = { props.update }\n                disabled = { props.disabled }>\n                { formattedOptions }\n            </select>\n        </div>\n    );\n}\n\nexport const SingleSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let formGroupClass = props.formGroupClass || \"form-row mb-3\";\n    let labelClass = props.labelClass || \"col-form-label text-uppercase\";\n    let selectClass = props.selectClass || \"form-control\";\n    return (\n        <div className={ formGroupClass }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClass }>\n                    { props.label }\n            </label>\n            <select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClass }\n                disabled={ props.disabled }>\n                { props.options }\n            </select>\n        </div>\n    );\n}\n\n\n/**\n * styling element to replace OptGroup headings in react multiselect checkbox widgets - used for\n * MultiSelectCheckbox when optgroups are required\n */\nconst GroupHeading = (props) => {\n    if (props.children == '') {\n        return <div></div>;\n    } else {\n        return (\n            <React.Fragment>\n                <hr style={{ margin: '3px 0px 0px 0px' }} />\n                <div className=\"text-muted\"\n                     style={{ textTransform: 'uppercase',\n                              paddingLeft: '4px',\n                              marginBottom: '2px'}}>\n                    { props.children }\n                </div>\n            </React.Fragment>\n            );\n    }\n}\n\n\n/**\n * Styles ReactMultiSelectCheckbox to fit Tola styles\n */\nexport const MultiSelectCheckbox = ( props ) => {\n    const selectId = uniqueId('multiselect');\n    const multiSelectProps = (!props.options || props.options.length == 0) ?\n            {\n                getDropdownButtonLabel: () => gettext('None available'),\n                isDisabled: true,\n                menuIsOpen: false,\n                options: [],\n            } :\n            {\n                isMulti: true,\n                options: props.options,\n                getDropdownButtonLabel: (_ref) => {\n                    if (!_ref.value) {\n                        return gettext('None selected');\n                    }\n                    if (Array.isArray(_ref.value)) {\n                        if (_ref.value.length == 0) {\n                            return gettext('None selected');\n                        }\n                        if (_ref.value.length == 1) {\n                            return _ref.value[0].label;\n                        }\n                        return `${_ref.value.length}  ${gettext('selected')}`;\n                    }\n                    return _ref.value.label;\n                }\n            };\n    const baseStyles = {\n        dropdownButton: base => (!props.options || props.options.length == 0)\n                            ? { ...base, backgroundColor: '#E5E6E8', background: '' }\n                            : base,\n        option: (provided, state) => ({\n                ...provided,\n                padding: '1px 12px',\n                display: 'inline-block'\n            }),\n        container: (provided, state) => ({\n                ...provided,\n                backgroundColor: '#f5f5f5'\n            }),\n    };\n    const formatOptionLabel = (props) => {\n        return <div style={{ display: \"inline-block\" , float: \"right\", width: \"90%\"}}>{props.label}</div>;\n    };\n    return (\n        <div className=\"form-row mb-2 tola-react-multiselect-row\">\n            <label htmlFor={ selectId } className=\"col-form-label text-uppercase\">\n                { props.label }\n            </label>\n            <ReactMultiSelectCheckboxes\n                id={ selectId }\n                styles={ baseStyles }\n                formatOptionLabel = { formatOptionLabel }\n                components={{ GroupHeading }}\n                value={ props.value }\n                onChange={ props.update }\n                { ...multiSelectProps }\n            />\n        </div>\n    );\n}\n\nexport const GroupBySelect = ({ chainLabel, ...selectProps }) => {\n    let options = [\n        <option value={ GROUP_BY_CHAIN } key={1}>{ chainLabel }</option>,\n        <option value={ GROUP_BY_LEVEL } key={2}>{\n            /* # Translators: refers to grouping the report by the level of the indicator */\n            gettext('by Level')\n        }</option>\n    ];;\n    return <SingleSelect\n                label={\n                    /* # Translators: menu for selecting how rows are grouped in a report */\n                    gettext('Group indicators')\n                }\n                options={ options }\n                { ...selectProps }\n            />;\n}\n","import { observable, computed, action, toJS, runInAction, autorun } from \"mobx\";\nimport { api } from \"../../api.js\"\n\nexport class RootStore {\n    constructor (program, levels, indicators, levelTiers, tierTemplates, englishTemplates, programObjectives, accessLevel, usingResultsFramework) {\n        this.levelStore =  new LevelStore(program, levels, indicators, levelTiers, tierTemplates, englishTemplates, programObjectives, accessLevel, usingResultsFramework, this);\n        this.uiStore = new UIStore(this);\n    }\n}\n\nexport class LevelStore {\n    @observable levels = [];\n    @observable indicators = [];\n    @observable chosenTierSetKey = \"\";\n    @observable chosenTierSet = [];\n    program_id;\n    tierTemplates;\n    programObjectives;\n    defaultTemplateKey = \"\";\n    customTierSetKey = \"\";\n    accessLevel = false;\n    usingResultsFramework;\n\n    constructor(program, levels, indicators, levelTiers, tierTemplates, englishTemplates, programObjectives, accessLevel, usingResultsFramework, rootStore) {\n        this.rootStore = rootStore;\n        this.levels = levels;\n        this.indicators = indicators;\n        this.tierTemplates = JSON.parse(tierTemplates);\n        this.englishTierTemlates = JSON.parse(englishTemplates);\n        this.defaultTemplateKey = \"mc_standard\";\n        this.customTierSetKey = \"custom\";\n        this.program_id = program.id;\n        this.manual_numbering = program.manual_numbering;\n        this.programObjectives = programObjectives;\n        this.accessLevel = accessLevel;\n\n        // Set the stored tier set key and the values, if they exist.  Use the default if they don't.\n        if (levelTiers.length > 0) {\n            const origLevelTiers = levelTiers.map( t => t.name)\n            this.chosenTierSetKey = this.deriveTemplateKey(origLevelTiers);\n            if (this.chosenTierSetKey == this.customTierSetKey) {\n                this.chosenTierSet = levelTiers.map(t => t.name);\n            }\n            else{\n                this.chosenTierSet = this.tierTemplates[this.chosenTierSetKey]['tiers']\n            }\n        }\n        else {\n            this.chosenTierSetKey = this.defaultTemplateKey;\n            this.chosenTierSet = this.tierTemplates[this.chosenTierSetKey]['tiers'];\n        }\n\n        this.usingResultsFramework = usingResultsFramework;\n\n    }\n\n    @computed get sortedLevels () {\n        return this.levels.slice().sort((a, b) => {a.level_depth - b.level_depth || a.customsort - b.customsort})\n    }\n\n    @computed get levelProperties () {\n        let levelProperties = {};\n\n        for (let level of this.levels) {\n            let properties = {};\n            const childrenIds = this.getChildLevels(level.id).map( l => l.id);\n            const indicatorCount = this.indicators.filter( i => i.level == level.id);\n\n            properties['indicators'] = this.getLevelIndicators(level.id);\n            properties['descendantIndicatorIds'] = this.getDescendantIndicatorIds(childrenIds);\n            properties['ontologyLabel'] = this.buildOntology(level.id);\n            properties['tierName'] = this.chosenTierSet[level.level_depth-1];\n            properties['childTierName'] = null;\n            if (this.chosenTierSet.length > level.level_depth) {\n                properties['childTierName'] = this.chosenTierSet[level.level_depth];\n            }\n\n            properties['canDelete'] = childrenIds.length==0 && indicatorCount==0 && this.accessLevel=='high';\n            properties['canEdit'] = this.accessLevel == 'high';\n            levelProperties[level.id] = properties;\n        }\n\n        return levelProperties\n    }\n\n    @computed get chosenTierSetName () {\n        if (this.chosenTierSetKey == this.customTierSetKey){\n            {/* # Translators: This signifies that the user has build their own level hierarchy instead of using one of the pre-defined ones */}\n            return gettext(\"Custom\")\n        }\n        else {\n            return this.tierTemplates[this.chosenTierSetKey]['name']\n        }\n    };\n\n    // This monitors the number of indicators attached to the program and adds/removes the header link depending on\n    // whether there are indicators.  It relies on all indicators being passed up from the server each time\n    // the indicator list is refreshed.\n    monitorHeaderLink = autorun( reaction => {\n        let headerSpan = $(\"#rf_builder_header\");\n        let linkedFlag = headerSpan.children(\"a\").length > 0;\n        if (this.indicators.length > 0 && !linkedFlag ) {\n            const headerText = headerSpan.text();\n            headerSpan.html(`<a href=\"/program/${this.program_id}/\">${headerText}</a>`)\n        }\n        else if (this.indicators.length == 0 && linkedFlag) {\n            const headerText = $(\"#rf_builder_header > a\").text();\n            headerSpan.text(headerText);\n        }\n    // delay is needed to prevent undefined value from being used for program_id that isn't set yet on first load.\n    }, {delay: 50});\n\n    @action\n    changeTierSet(newTierSetKey) {\n        this.chosenTierSetKey = newTierSetKey;\n        this.chosenTierSet = this.tierTemplates[newTierSetKey]['tiers']\n    }\n\n    @action\n    cancelEdit = levelId => {\n        if (levelId == \"new\") {\n            const targetLevel = this.levels.find(l => l.id == levelId);\n\n            // First update any customsort values that were modified when this card was created\n            let siblingsToReorder = this.levels.filter(l => {\n                return l.customsort > targetLevel.customsort && l.parent == targetLevel.parent;\n            });\n            siblingsToReorder.forEach(sib => sib.customsort -= 1);\n\n            // Now remove the new card\n            this.levels.replace(this.levels.filter((element) => element.id != \"new\"));\n        }\n\n        this.fetchIndicatorsFromDB();\n        this.rootStore.uiStore.removeActiveCard();\n    };\n\n    @action\n    createNewLevelFromSibling = (siblingId) => {\n        // Copy sibling data for the new level and then clear some of it out\n        let sibling = toJS(this.levels.find( l => l.id == siblingId));\n        let newLevel = Object.assign({}, sibling);\n        newLevel.customsort += 1;\n        newLevel.id = \"new\";\n        newLevel.name = \"\";\n        newLevel.assumptions = \"\";\n\n        // bump the customsort field for siblings that come after the inserted Level\n        let siblingsToReorder = this.levels.filter( l => {\n            return sibling && l.customsort > sibling.customsort && l.parent == sibling.parent;\n        });\n        siblingsToReorder.forEach( sib => sib.customsort+=1);\n        // add new Level to the various Store components\n        this.rootStore.uiStore.activeCard = \"new\";\n        this.levels.push(newLevel);\n        setTimeout(\n            function(){$(\"#level-card-new\")[0].scrollIntoView({behavior:\"smooth\"})},\n            100\n        )\n    };\n\n    @action\n    createNewLevelFromParent = (parentId) => {\n        // Copy data for the new level and then clear some of it out\n        let parent = toJS(this.levels.find( l => l.id == parentId));\n        let newLevel = {\n            id:\"new\",\n            customsort: 1,\n            name: \"\",\n            assumptions: \"\",\n            parent: parentId,\n            level_depth: parent.level_depth + 1,\n            program: this.program_id\n        };\n\n        // bump the customsort field for siblings that come after the inserted Level\n        let siblingsToReorder = this.levels.filter( l => l.parent == parentId);\n\n        siblingsToReorder.forEach( sib => sib.customsort+=1);\n        // add new Level to the various Store components\n        this.levels.push(newLevel);\n        this.rootStore.uiStore.activeCard = \"new\";\n        this.rootStore.uiStore.hasVisibleChildren.push(newLevel.parent)\n\n    };\n\n    @action\n    createFirstLevel = () => {\n        // Using \"root\" for parent id so the Django view can distinguish between top tier level and 2nd tier level\n        let newLevel = {\n            id: \"new\",\n            program: this.program_id,\n            name: \"\",\n            assumptions: \"\",\n            customsort: 1,\n            level_depth: 1,\n            parent: \"root\"\n        };\n        this.levels.push(newLevel);\n        this.rootStore.uiStore.activeCard = \"new\";\n    };\n\n    saveLevelTiersToDB = () => {\n        const tier_data = {program_id: this.program_id};\n        if (this.chosenTierSetKey === \"custom\") {\n            tier_data.tiers = this.chosenTierSet;\n        }\n        else {\n            tier_data.tiers = this.englishTierTemlates[this.chosenTierSetKey]['tiers']\n        }\n        api.post(`/save_leveltiers/`, tier_data)\n            .then(response => {\n            })\n            .catch(error => console.log('error', error))\n    };\n\n    deleteLevelFromDB = (levelId) => {\n        const level_label = `${this.levelProperties[levelId]['tierName']} ${this.levelProperties[levelId]['ontologyLabel']}`;\n        api.delete(`/level/${levelId}`)\n            .then(response => {\n                this.levels.replace(response.data);\n                this.rootStore.uiStore.activeCard = null;\n                if (this.levels.length == 0){\n                    this.createFirstLevel()\n                }\n\n\n                success_notice({\n                    /* # Translators: Notification to user that the deletion command that they issued was successful */\n                    message_text: interpolate(gettext(\"%s was deleted.\"), [level_label]),\n                    addClass: 'program-page__rationale-form',\n                    stack: {\n                        dir1: 'up',\n                        dir2: 'right',\n                        firstpos1: 20,\n                        firstpos2: 20,\n                    }\n                })\n            })\n            .catch(error => console.log('error', error))\n\n        this.rootStore.uiStore.setDisableForPrompt(false);\n    };\n\n\n    // TODO: better error handling for API\n    saveLevelToDB = (submitType, levelId, indicatorWasUpdated, formData) => {\n        // if indicators have been updated, call a separate save method and remove the data from object that will be sent with the level saving post request\n        if (indicatorWasUpdated) {\n            this.saveReorderedIndicatorsToDB(formData.indicators)\n        }\n        delete formData.indicators;\n\n        // Now process the save differently depending on if it's a new level or a pre-existing one.\n        let targetLevel = this.levels.find(level => level.id == levelId);\n        const level_label = `${this.levelProperties[levelId].tierName} ${this.levelProperties[levelId].ontologyLabel}`;\n        let levelToSave = Object.assign(toJS(targetLevel), formData);\n        const levelDataWasUpdated = this.rootStore.uiStore.activeCardNeedsConfirm;\n        if (levelId == \"new\") {\n            if (levelToSave.parent == \"root\") {\n                this.saveLevelTiersToDB();\n                $('#logframe_link').show();\n            }\n\n            // Don't need id, since it will be \"new\", and don't need rationale, since it's a new level.\n            delete levelToSave.id;\n            delete levelToSave.rationale;\n\n            api.post(`/insert_new_level/`, levelToSave)\n                .then(response => {\n                    runInAction(() => {\n                        this.levels.replace(response.data['all_data'])\n                    });\n\n                    success_notice({\n                        // # Translators: This is a confirmation message that confirms that change has been successfully saved to the DB.\n                        message_text: interpolate(gettext(\"%s saved.\"), [level_label]),\n                        addClass: 'program-page__rationale-form',\n                        stack: {\n                            dir1: 'up',\n                            dir2: 'right',\n                            firstpos1: 20,\n                            firstpos2: 20,\n                        }\n                    });\n\n                    const newId = response.data[\"new_level\"][\"id\"];\n                    this.rootStore.uiStore.activeCard = null;\n                    if (submitType == \"saveAndEnableIndicators\") {\n                        runInAction( () => {\n                           this.rootStore.uiStore.activeCard = newId;\n                        });\n                    }\n                    else if (submitType == \"saveAndAddSibling\"){\n                        this.createNewLevelFromSibling(newId);\n\n                    }\n                    else if (submitType == \"saveAndAddChild\"){\n                        this.createNewLevelFromParent(newId);\n\n                    }\n                })\n                .catch(error => console.log('error', error))\n\n        } else {\n            api.put(`/level/${levelId}/`, levelToSave)\n                .then(response => {\n                    if (levelDataWasUpdated || indicatorWasUpdated) {\n                        success_notice({\n                            // # Translators:  Confirmation message that user-supplied updates were successfully applied.\n                            message_text: interpolate(gettext(\"%s updated.\"), [level_label]),\n                            addClass: 'program-page__rationale-form',\n                            stack: {\n                                dir1: 'up',\n                                dir2: 'right',\n                                firstpos1: 20,\n                                firstpos2: 20,\n                            }\n                        });\n                    }\n                    runInAction( () => {\n                        Object.assign(targetLevel, response.data);\n                    });\n                    this.rootStore.uiStore.activeCard = null;\n                    if (submitType == \"saveAndAddSibling\"){\n                        this.createNewLevelFromSibling(levelId);\n                    }\n                    else if (submitType == \"saveAndAddChild\"){\n                        this.createNewLevelFromParent(levelId);\n                    }\n\n                })\n                .catch( error => {\n                    console.log(\"There was an error:\", error);\n                })\n        }\n\n        this.fetchIndicatorsFromDB();\n\n        this.rootStore.uiStore.activeCardNeedsConfirm = false;\n    };\n\n    saveReorderedIndicatorsToDB = indicators => {\n        api.post(\"/reorder_indicators/\", indicators)\n                .then(response => {\n                   this.fetchIndicatorsFromDB()\n                })\n                .catch( error => {\n                    console.log(\"There was an error:\", error);\n                })\n    };\n\n    @action\n    updateIndicatorNameInStore(indicatorId, newName) {\n        this.indicators.find( i => i.id == indicatorId).name = newName;\n    }\n\n    @action\n    deleteIndicatorFromStore = (indicatorId, levelId) => {\n        this.indicators = this.indicators.filter( i => i.id != indicatorId);\n        this.indicators\n            .filter( i => i.level == levelId)\n            .sort( (a, b) => a.level_order - b.level_order)\n            .forEach( (indicator, index) => indicator.level_order = index);\n    };\n\n    @action\n    addIndicatorToStore = (indicatorData) => {\n        this.indicators.push(indicatorData);\n    };\n\n    @action\n    moveIndicatorInStore = (indicatorId, newLevelId) => {\n        let target = this.indicators.find( i => i.id == indicatorId);\n        target.level = newLevelId;\n        target.level_order = this.indicators.filter( i => i.level == newLevelId).length -1;\n    };\n\n    fetchIndicatorsFromDB = (indicatorId=null) => {\n        const indicatorQParam = indicatorId ? `?indicatorId=${indicatorId}` : \"\";\n        api.get(`/indicator_list/${this.program_id}/${indicatorQParam}`)\n            .then((response) => runInAction(() => {\n                this.indicators = response.data;\n            }))\n            .catch((error) => console.log('There was an error:', error));\n    };\n\n    deriveTemplateKey = (origLevelTiers) => {\n        // Check each tier set in the templates to see if the tier order and content are exactly the same\n        // If they are, return the template key\n        const levelTierStr = JSON.stringify(toJS(origLevelTiers));\n        for (let templateKey in this.englishTierTemlates){\n            // not an eligable template if the key is inherited or if the lengths of the tier sets don't match.\n            if (!this.englishTierTemlates.hasOwnProperty(templateKey) ||\n                origLevelTiers.length != this.englishTierTemlates[templateKey]['tiers'].length) {\n                continue;\n            }\n            const templateValuesStr = JSON.stringify(this.englishTierTemlates[templateKey]['tiers']);\n            if (levelTierStr == templateValuesStr) {\n                return templateKey;\n            }\n        }\n\n        // If this has been reached, the db has stored tiers but they're not a match to a template\n        return this.customTierSetKey;\n    };\n\n\n    buildOntology = (levelId, ontologyArray = []) => {\n        let level = toJS(this.levels.find( l => l.id == levelId));\n        /*  If there is no parent (saved top tier level) or the parent is \"root\" (unsaved top tier level)\n            then we should return with adding to the ontology because there is no ontology entry for the top tier\n         */\n        if (level.parent && level.parent != \"root\") {\n            ontologyArray.unshift(level.customsort);\n            return this.buildOntology(level.parent, ontologyArray);\n        }\n        else {\n            return ontologyArray.join(\".\");\n        }\n    };\n\n    getChildLevels = levelId => this.levels.filter( l => l.parent == levelId);\n\n    getLevelIndicators = levelId => this.indicators.filter( i => i.level == levelId);\n\n    getDescendantIndicatorIds = (childLevelIds) => {\n        const childLevels = this.levels.filter( l => childLevelIds.includes(l.id));\n        let newIndicatorIds = [];\n        childLevels.forEach( childLevel => {\n            newIndicatorIds = newIndicatorIds.concat(this.indicators.filter( i => i.level == childLevel.id).map( i => i.id));\n            let grandChildIds = this.levels.filter( l => l.parent == childLevel.id).map( l => l.id);\n            newIndicatorIds = newIndicatorIds.concat(this.getDescendantIndicatorIds(grandChildIds, newIndicatorIds));\n        });\n        return newIndicatorIds\n    }\n\n}\n\n\nexport class UIStore {\n\n    @observable activeCard;\n    @observable hasVisibleChildren = [];\n    @observable disableForPrompt;\n    activeCardNeedsConfirm = \"\";\n\n    constructor (rootStore) {\n        this.rootStore = rootStore;\n        this.hasVisibleChildren = this.rootStore.levelStore.levels.map(l => l.id)\n        this.activeCardNeedsConfirm = false;\n        this.activeCard = null;\n        this.disableForPrompt = false;\n    }\n\n    @computed get tierLockStatus () {\n        // The leveltier picker should be disabled if there is at least one saved level in the DB.\n        let notNewLevels = this.rootStore.levelStore.levels.filter( l => l.id != \"new\");\n        if  (notNewLevels.length > 0) {\n            return \"locked\"\n        }\n        // The apply button should not be visible if there is only one level visible (i.e. saved to the db or not)\n        else if (this.rootStore.levelStore.levels.length == 1){\n            return \"primed\"\n        }\n\n        return null;\n    }\n    // TODO: Make sure old editing data is not preserved when an edit is cancelled\n    @action\n    editCard = (levelId) => {\n        const cancelledLevelId = this.activeCard;\n        if (this.activeCardNeedsConfirm) {\n            this.setDisableForPrompt(true);\n            $(`#level-card-${this.activeCard}`)[0].scrollIntoView({behavior:\"smooth\"});\n            const oldTierName = this.rootStore.levelStore.levelProperties[this.activeCard].tierName;\n            create_no_rationale_changeset_notice({\n                /* # Translators:  This is a confirmation prompt that is triggered by clicking on a cancel button.  */\n                message_text: gettext(\"Are you sure you want to continue?\"),\n                /* # Translators:  This is a warning provided to the user when they try to cancel the editing of something they have already modified.  */\n                preamble: interpolate(gettext(\"Changes to this %s will not be saved\"), [oldTierName]),\n                type: \"notice\",\n                on_submit: () => this.onLeaveConfirm(levelId, cancelledLevelId),\n                on_cancel: () => this.setDisableForPrompt(false),\n            })\n        }\n        else {\n            this.activeCard = levelId;\n            this.rootStore.levelStore.levels.replace(this.rootStore.levelStore.levels.filter( l => l.id != \"new\"))\n        }\n    };\n\n    @action\n    onLeaveConfirm = (levelId, cancelledLevelId) => {\n        this.setDisableForPrompt(false);\n        this.rootStore.levelStore.cancelEdit(cancelledLevelId);\n        this.activeCardNeedsConfirm = false;\n        this.activeCard = levelId;\n        // Need to use set timeout to ensure that scrolling loses the race with components reacting to the new position of the open card.\n        setTimeout(\n            function(){$(`#level-card-${levelId}`)[0].scrollIntoView({behavior:\"smooth\"})},\n            100\n        );\n    };\n\n    @action\n    setDisableForPrompt = (value) => {\n        this.disableForPrompt = value;\n    };\n\n    @action\n    removeActiveCard = () => {\n        this.activeCard = null;\n        this.rootStore.uiStore.activeCardNeedsConfirm = false;\n    };\n\n    @action\n    updateVisibleChildren = (levelId, forceHide=false, forceShow=false) => {\n        // forceHide is to ensure that descendant levels are also made hidden, even if they are not actually visible.\n        if (this.hasVisibleChildren.indexOf(levelId) >= 0 || forceHide) {\n            this.hasVisibleChildren = this.hasVisibleChildren.filter( level_id => level_id != levelId );\n            const childLevels = this.rootStore.levelStore.levels.filter( l => l.parent == levelId);\n            childLevels.forEach( l => this.updateVisibleChildren(l.id, true))\n        }\n        else {\n            this.hasVisibleChildren.push(levelId);\n        }\n    }\n}\n","/*\n * ID generating code &c. for form inputs\n */\n\nlet lastId = 0;\n\nexport function uniqueId (prefix='id') {\n    lastId++;\n    return `${prefix}${lastId}`;\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from \"mobx-react\"\nimport eventBus from '../../eventbus';\nimport createRouter from 'router5';\nimport browserPlugin from 'router5-plugin-browser';\nimport {reloadPageIfCached} from '../../general_utilities';\nimport {LevelListPanel} from './components/level_list';\nimport {LevelTierPicker} from './components/leveltier_picker';\nimport {RootStore} from './models';\n\n/*\n * Model/Store setup\n */\nconst {program, levels, indicators, levelTiers, tierTemplates, englishTemplates, programObjectives, accessLevel, usingResultsFramework} = jsContext;\nconst rootStore = new RootStore(program, levels, indicators, levelTiers, tierTemplates, englishTemplates, programObjectives, accessLevel, usingResultsFramework);\n/*\n * React components on page\n */\n\nReactDOM.render(\n    <Provider rootStore={rootStore}>\n        <React.Fragment>\n            <LevelTierPicker />\n            <LevelListPanel />\n        </React.Fragment>\n    </Provider>,\n    document.querySelector('#level-builder-react-component'));\n\n\n\nreloadPageIfCached();\n","function flattenArray(arr, depth = 1) {\n    if (depth == 5) {\n        return arr;\n    }\n    let flattened = [];\n    arr.forEach(item => {\n        if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item, depth+1));\n        } else {\n            flattened.push(item);\n        }\n    });\n    return flattened;\n}\n\nfunction ensureNumericArray(value) {\n    if (!Array.isArray(value)) {\n        value = parseInt(value);\n        if (value && !isNaN(value)) {\n            return [value];\n        }\n        return false;\n    }\n    let arr = value.map(x => parseInt(x)).filter(x => !isNaN(x));\n    if (arr && Array.isArray(arr) && arr.length > 0) {\n        return arr;\n    }\n    return false;\n}\n\n/*\n * Are we loading a cached page? If so, reload to avoid displaying stale indicator data\n * See ticket #1423\n */\nfunction reloadPageIfCached() {\n    // moving the cache check to after page load as firefox calculates transfer size at the end\n    $(function () {\n        let isCached = window.performance.getEntriesByType(\"navigation\")[0].transferSize === 0;\n        //adding a second check to ensure that if for whatever reason teh transfersize reads wrong, we don't reload on\n        //a reload:\n        let isReload = window.performance.getEntriesByType(\"navigation\")[0].type === \"reload\";\n        if (isCached && !isReload) {\n            window.location.reload();\n        }\n    });\n}\n\nconst indicatorManualNumberSort = (levelFunc, numberFunc) => {\n    return (indicatorA, indicatorB) => {\n        let levelA = levelFunc(indicatorA);\n        let levelB = levelFunc(indicatorB);\n        if (levelA && !levelB) {\n            return 1;\n        }\n        if (levelB && !levelA) {\n            return -1;\n        }\n        if (levelA != levelB) {\n            return parseInt(levelA) - parseInt(levelB);\n        }\n        let numberA = (numberFunc(indicatorA) || '').split('.');\n        let numberB = (numberFunc(indicatorB) || '').split('.');\n        for (let i=0; i < Math.max(numberA.length, numberB.length); i++) {\n            if (numberA[i] && numberB[i]) {\n                for (let j=0; j < Math.max(numberA[i].length, numberB[i].length); j++) {\n                    if (numberA[i][j] && numberB[i][j]) {\n                        if (numberA[i].charCodeAt(j) != numberB[i].charCodeAt(j)) {\n                            return numberA[i].charCodeAt(j) - numberB[i].charCodeAt(j);\n                        }\n                    } else if (numberA[i][j]) {\n                        return 1;\n                    } else if (numberB[i][j]) {\n                        return -1;\n                    }\n                }\n            } else if (numberA[i]) {\n                return 1;\n            } else if (numberB[i]) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n}\n\nexport { flattenArray, ensureNumericArray, reloadPageIfCached, indicatorManualNumberSort };\n","import axios from 'axios';\n\nexport const api = axios.create({\n    withCredentials: true,\n    baseURL: '/api/',\n    headers: {\n        \"X-CSRFToken\": document.cookie.replace(/(?:(?:^|.*;\\s*)csrftoken\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\")\n    }\n});\n","import React from 'react';\nimport { observer } from 'mobx-react';\n\nexport const AddIndicatorButton = observer(({ readonly, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-link btn-add\"\n                onClick={e => {openCreateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-plus-circle\"/> {gettext(\"Add indicator\")}\n            </button>\n    );\n});\n\n\nexport const UpdateIndicatorButton = observer(({ readonly, label=null, ...params }) => {\n    return (\n            <button\n                type=\"button\"\n                disabled={readonly}\n                className=\"btn btn-link\"\n                onClick={e => {openUpdateIndicatorFormModal(params)}}>\n                <i className=\"fas fa-cog\"/>{label}\n            </button>\n    );\n});\n","// A global instance of an event bus\nimport nanobus from 'nanobus';\n\nconst globalEventBus = nanobus();\n\nexport default globalEventBus;\n","import React from 'react';\nimport { observer, inject } from \"mobx-react\"\nimport { toJS } from 'mobx';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\nimport {LevelCardCollapsed, LevelCardExpanded} from \"./level_cards\";\n\nlibrary.add(faCaretDown, faCaretRight);\n\n@inject('rootStore')\n@observer\nclass LevelList extends React.Component {\n\n    render() {\n        let renderList = [];\n        if (this.props.renderList == 'initial') {\n            renderList = this.props.rootStore.levelStore.sortedLevels\n                .filter(level => ['root', null].indexOf(level.parent) != -1)\n        }\n\n        else{\n            renderList = this.props.renderList.sort((a, b) => a.customsort - b.customsort);\n        }\n\n        return renderList.map((elem) => {\n            let card = '';\n            if (this.props.rootStore.uiStore.activeCard == elem.id) {\n                card =\n                    <LevelCardExpanded\n                        level={elem}\n                        levelProps={this.props.rootStore.levelStore.levelProperties[elem.id]}/>\n            }\n            else {\n                card =\n                    <LevelCardCollapsed\n                        level={elem}\n                        levelProps={this.props.rootStore.levelStore.levelProperties[elem.id]}/>\n            }\n\n            let children = this.props.rootStore.levelStore.sortedLevels.filter(level => level.parent == elem.id);\n            let childLevels = null;\n            if (children.length > 0){\n                childLevels =  <LevelList\n                    rootStore={this.props.rootStore}\n                    renderList={children}/>\n            }\n\n            return (\n                <div key={elem.id} className=\"leveltier--new\">\n                    {card}\n                    {childLevels}\n                </div>\n            )\n    })}\n}\n\n@inject('rootStore')\n@observer\nexport class LevelListPanel  extends React.Component {\n\n    getWarningText = () => {\n        return {__html: gettext('<strong class=\"text-danger\">Choose your results framework template carefully!</strong> Once you begin building your framework, it will not be possible to change templates without first deleting all saved levels.') }\n    };\n\n    render() {\n        if (this.props.rootStore.levelStore.levels.length == 0) {\n            return (\n                <div className=\"level-list-panel\">\n                    <div className=\"level-list-panel__dingbat\">\n                        <i className=\"fas fa-sitemap\"></i>\n                    </div>\n                    <div className=\"level-list-panel__text text-large\"\n                        dangerouslySetInnerHTML={this.getWarningText()}/>\n\n                </div>\n            )\n        }\n        else {\n            return (\n                <div id=\"level-list\" style={{flexGrow: \"2\"}}><LevelList renderList='initial'/></div>\n            )\n        }\n    }\n}\n\n","\n/**\n * IPTT Constants:\n */\nconst BLANK_LABEL = '---------';\nconst BLANK_OPTION = {\n    value: null,\n    label: BLANK_LABEL\n};\nconst BLANK_TABLE_CELL = '—';\n\n\nconst TVA = 1;\nconst TIMEPERIODS = 2;\n\nconst TIME_AWARE_FREQUENCIES = [3, 4, 5, 6, 7];\n\nexport { BLANK_OPTION, BLANK_LABEL, BLANK_TABLE_CELL, TVA, TIMEPERIODS, TIME_AWARE_FREQUENCIES };\n\nconst GROUP_BY_CHAIN = 1;\nconst GROUP_BY_LEVEL = 2;\n\nexport { GROUP_BY_CHAIN, GROUP_BY_LEVEL };\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nfunction getPeriodLabels() {\n    return {\n        targetperiodLabels: {\n            1: _gettext(\"Life of Program (LoP) only\"),\n            3: _gettext(\"Annual\"),\n            2: _gettext(\"Midline and endline\"),\n            5: _gettext(\"Tri-annual\"),\n            4: _gettext(\"Semi-annual\"),\n            7: _gettext(\"Monthly\"),\n            6: _gettext(\"Quarterly\")\n        },\n        timeperiodLabels: {\n            3: _gettext(\"Years\"),\n            5: _gettext(\"Tri-annual periods\"),\n            4: _gettext(\"Semi-annual periods\"),\n            7: _gettext(\"Months\"),\n            6: _gettext(\"Quarters\")\n        }\n    };\n}\n\nexport {getPeriodLabels};\n\nexport const STATUS_CODES = {\n    NO_INDICATOR_IN_UPDATE: 1\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AAIA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AACA;AACA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AASA;;;;AA3DA;AACA;AA6DA;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AACA;;;;AALA;AACA;AASA;;;;;;;;;;;;;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AAAA;AAOA;;;;AApCA;AACA;AAsCA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAKA;AAAA;AAEA;AATA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/IA;AACA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAHA;AAIA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AAAA;AAEA;;;;AAlBA;AACA;AADA;AAsBA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AA/BA;AAiCA;AACA;AACA;AAnCA;AAAA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAGA;AACA;AAAA;AAOA;AAXA;AACA;AADA;AAAA;AACA;AAaA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;;;;;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAXA;AAYA;AAAA;AAIA;;;;AAzCA;AACA;AA6CA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAMA;AACA;AAZA;AAcA;AACA;AACA;AAhBA;AAgCA;AACA;AAAA;AAAA;AACA;AACA;AACA;AApCA;AAAA;AACA;AADA;AAAA;AAAA;AAkBA;AACA;AACA;AADA;AAGA;AAtBA;AAAA;AAAA;AAyBA;AACA;AACA;AADA;AAGA;AA7BA;AAAA;AAAA;AAqCA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAFA;AAIA;AAAA;AAEA;AACA;AACA;AAHA;AAQA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAHA;AAIA;AAAA;AAKA;AACA;AACA;AAHA;AAIA;AAAA;AAIA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAeA;AAnJA;AACA;AADA;AAAA;AAyJA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AA+CA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AArDA;AAwDA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAjEA;AAuEA;AACA;AACA;AAzEA;AAsIA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAFA;AAIA;AAEA;AACA;AACA;AACA;AAjKA;AAmKA;AACA;AACA;AAEA;AACA;AACA;AACA;AA1KA;AA4KA;AACA;AACA;AACA;AA/KA;AAiLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAjMA;AAmMA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxMA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AA3BA;AA8BA;AACA;AACA;AAHA;AAxCA;AA6CA;AACA;AA/CA;AAAA;AAAA;AA4EA;AACA;AACA;AACA;AADA;AAGA;AAjFA;AAAA;AAAA;AAmFA;AACA;AAAA;AACA;AACA;AADA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9HA;AAAA;AAAA;AAiIA;AACA;AACA;AACA;AApIA;AAAA;AAAA;AA4MA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAMA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAHA;AAOA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAYA;AACA;AACA;AACA;AACA;AACA;AANA;AAYA;AApSA;AACA;AADA;AAAA;AAySA;;;;;;;;;;;;;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AA7BA;AACA;AA+BA;;;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAUA;;;;AAfA;AACA;AAkBA;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AADA;AAIA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AATA;AAWA;AAAA;AAGA;AACA;AACA;AAHA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAKA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAJA;AADA;AAQA;AAAA;AAEA;AACA;AACA;AAHA;AAQA;;;;AA9GA;AAiHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1rBA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAEA;AACA;AACA;AAEA;AAAA;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AAGA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAGA;;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAFA;AADA;AAQA;AACA;AAGA;;;;;AAGA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAjBA;AAmBA;AACA;AAAA;AACA;AAAA;AADA;AAAA;AAGA;AAAA;AAEA;AACA;AAHA;AAAA;AAKA;AAAA;AAEA;AAFA;AAAA;AATA;AACA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AANA;AAWA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AALA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5MA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AAAA;AAaA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4EA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAxFA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAoLA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AAhMA;AAkMA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AA5NA;AAgOA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAYA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9TA;AAgUA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAxUA;AACA;AADA;AACA;AADA;AACA;AADA;AAmWA;AACA;AACA;AACA;AACA;AACA;AAFA;AAGA;AAAA;AACA;AACA;AA3WA;AA6WA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/XA;AAiYA;AACA;AAAA;AAAA;AACA;;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA9YA;AA+YA;AAAA;AAAA;AAAA;AACA;AAhZA;AAiZA;AAAA;AAAA;AAAA;AACA;AAlZA;AAoZA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AA5ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AA7CA;AAAA;AAAA;AAwGA;AACA;AACA;AA1GA;AAAA;AAAA;AAwVA;AAAA;AAAA;AACA;AAzVA;AAAA;AAAA;AA+CA;AAAA;AAAA;AACA;AAhDA;AAAA;AAAA;AAkDA;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AACA;AAEA;AAAA;AAiBA;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAqBA;AACA;AAzEA;AAAA;AAAA;AA4EA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAnFA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA8GA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AA7HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAiIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AArJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAyJA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AAUA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AA9KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAkLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AAQA;AACA;AAAA;AACA;AA9LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA6VA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAlWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAsWA;AACA;AAvWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA2WA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AA9WA;AAAA;AA8aA;AAAA;AAAA;AAOA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAdA;AAAA;AAAA;AAgBA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AA5BA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA+BA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAPA;AASA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAlDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAsDA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AA/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAmEA;AACA;AApEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAwEA;AACA;AACA;AA1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AA6EA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAvFA;AAAA;;;;;;;;;;;;ACxbA;AAAA;AAAA;;;AAIA;AAEA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AAIA;AACA;AAAA;AAUA;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAKA;AAAA;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAKA;AAAA;AAGA;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;;;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAFA;AAGA;AAEA;AAEA;AACA;AAFA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AAAA;;;;AA1CA;AA+CA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAGA;AAAA;AAAA;AACA;AACA;AALA;AAAA;AACA;AADA;AAAA;AAAA;AAOA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AADA;AAKA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAxBA;AACA;AADA;AAAA;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AACA;AACA;AACA;AAFA;AAIA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAVA;AAkBA;AACA;AACA;AAEA;AACA;AADA;;;;A","sourceRoot":""}