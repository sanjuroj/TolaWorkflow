{"version":3,"file":"iptt_report-a2a92742310da9b74393.js","sources":["webpack:///./js/pages/iptt_report/components/report/headerCells.js","webpack:///./js/pages/iptt_report/components/main.js","webpack:///./js/components/helpPopover.js","webpack:///./js/pages/iptt_report/models/programStore.js","webpack:///./js/pages/iptt_report/components/report/buttons.js","webpack:///./js/pages/iptt_report/components/report/tableRows.js","webpack:///./js/components/selectWidgets.js","webpack:///./js/formUtils.js","webpack:///./js/pages/iptt_report/components/sidebar/reportFilter.js","webpack:///./js/pages/iptt_report/components/report/ipttReport.js","webpack:///./js/pages/iptt_report/models/filterStore.js","webpack:///./js/pages/iptt_report/components/sidebar/sidebar.js","webpack:///./js/pages/iptt_report/components/report/tableHeader.js","webpack:///./js/pages/iptt_report/components/sidebar/filterForm.js","webpack:///./js/general_utilities.js","webpack:///./js/pages/iptt_report/router.js","webpack:///./js/pages/iptt_report/components/sidebar/buttons.js","webpack:///./js/pages/iptt_report/components/report/table.js","webpack:///./js/pages/iptt_report/components/report/tableBody.js","webpack:///./js/pages/iptt_report/index.js","webpack:///./js/pages/iptt_report/components/report/header.js","webpack:///./js/pages/iptt_report/models/reportStore.js","webpack:///./js/constants.js","webpack:///./js/pages/iptt_report/components/sidebar/reportSelect.js","webpack:///./js/pages/iptt_report/api.js"],"sourcesContent":["import React from 'react';\n\nconst BorderedHeader = ( { label, styleWidth } ) => {\n    let style = styleWidth ? {\n        minWidth: `${styleWidth}px`\n    } : {};\n    return (\n        <th\n            scope=\"col\"\n            className=\"align-bottom text-uppercase\"\n            style={style}\n        >{ label }</th>\n    );\n}\n\nconst UnBorderedHeader = ( props ) => {\n    let style = props.styleWidth ? {\n        minWidth: `${props.styleWidth}px`\n    } : {};\n    return (\n        <th\n            scope=\"col\"\n            className=\"align-bottom text-uppercase td-no-side-borders\"\n            style={style}\n        >{ props.label }</th>\n    );\n}\n\nconst PeriodHeader = ( props ) => {\n    return (\n        <td scope=\"colgroup\" colSpan={ props.isTVA ? 3 : 1}\n            className=\"text-center title-row text-nowrap align-bottom\">\n            <span className=\"text-uppercase\">{ props.period.name }</span>\n            { props.period.range &&\n                <React.Fragment>\n                    <br />\n                    <small>{ props.period.range }</small>\n                </React.Fragment>\n            }\n        </td>\n    )\n}\n\nconst TargetHeader = () => {\n    return (\n        <th\n            scope=\"col\"\n            className=\"align-bottom text-uppercase text-right\"\n            style={{minWidth: '110px'}}>\n            {\n                /* # Translators: Column header for a target value column */\n                gettext('Target')\n            }\n        </th>\n    )\n}\n\nconst ActualHeader = () => {\n    return (\n        <th\n            scope=\"col\"\n            className=\"align-bottom text-uppercase text-right\"\n            style={{minWidth: '110px'}}>\n            {\n                /* # Translators: Column header for an \"actual\" or achieved/real value column */\n                gettext('Actual')\n            }\n        </th>\n    )\n}\n\nconst PercentMetHeader = () => {\n    return (\n        <th\n            scope=\"col\"\n            className=\"align-bottom text-uppercase text-right\"\n            style={{minWidth: '110px'}}>\n            {\n                /* # Translators: Column header for a percent-met column */\n                gettext('% met')\n            }\n        </th>\n    )\n}\n\nconst TVAHeader = () => {\n    return (\n        <React.Fragment>\n            <TargetHeader />\n            <ActualHeader />\n            <PercentMetHeader />\n        </React.Fragment>\n    )\n}\n\nexport { BorderedHeader, UnBorderedHeader, PeriodHeader, TVAHeader, ActualHeader }","import React from 'react';\nimport IPTTSidebar from './sidebar/sidebar';\nimport IPTTReport from './report/ipttReport';\n\n\n\n\nconst IPTTReportApp = () => {\n    return <React.Fragment>\n                <IPTTSidebar />\n                <IPTTReport />\n            </React.Fragment>\n}\n\nexport default IPTTReportApp;","import React from 'react'\nimport ReactDOM from 'react-dom';\n\nexport default class HelpPopover extends React.Component {\n    constructor(props) {\n        super(props)\n        this.content = props.content;\n        this.placement = props.placement || null;\n    }\n\n    render() {\n        return (\n            <a\n                tabIndex=\"0\"\n                data-toggle=\"popover\"\n                data-trigger=\"focus\"\n                data-html=\"true\"\n                data-placement={this.placement}\n                data-content={this.content}>\n            <i className=\"far fa-question-circle\"></i></a>\n        )\n    }\n}\n\n\nexport class BootstrapPopoverButton extends React.Component {\n    popoverName = 'base';\n\n    componentDidMount = () => {\n        // make a cancelable (class method) function so clicking out of the popover will close it:\n        this.bodyClickHandler = (ev) => {\n            if ($(`#${this.popoverName}_popover_content`).parent().find($(ev.target)).length == 0) {\n                $(this.refs.target).popover('hide');\n            }\n        }\n        const popoverOpenHandler = () => {\n            // first make it so any click outside of the popover will hide it:\n            $('body').on('click', this.bodyClickHandler);\n            // update position (it's had content loaded):\n            $(this.refs.target).popover('update')\n                //when it hides destroy the body clickhandler:\n                .on('hide.bs.popover', () => {$('body').off('click', this.bodyClickHandler);});\n        };\n        const shownFn = (ev) => {\n            ReactDOM.render(\n                this.getPopoverContent(),\n                document.querySelector(`#${this.popoverName}_popover_content`),\n                popoverOpenHandler\n            );\n        };\n        $(this.refs.target).popover({\n            content: `<div id=\"${this.popoverName}_popover_content\"></div>`,\n            html: true,\n            placement: 'bottom'\n        }).on('shown.bs.popover', shownFn);\n    }\n    \n    getPopoverContent = () => {\n        throw new Error('not implemented');\n    }\n}","import { observable, computed, action } from 'mobx';\nimport { TVA, TIMEPERIODS, TIME_AWARE_FREQUENCIES, STATUS_CODES } from '../../../constants';\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nclass Indicator {\n    program = null;\n    pk = null;\n    levelpk = null;\n    number = null;\n    name = null;\n    unitOfMeasure = null;\n    directionOfChange = null;\n    is_cumulative = null;\n    unitType = null;\n    baseline = null;\n    baseline_na = null;\n    typePks = [];\n    sitePks = [];\n    sectorPk = null;\n    lopTarget = null;\n    lopActual = null;\n    lopMet = null;\n    frequency = null;\n    sortIndex = null;\n    reportData = {\n        [TIMEPERIODS]: {},\n        [TVA]: {}\n    };\n\n    constructor(indicatorJSON, program) {\n        this.pk = parseInt(indicatorJSON.pk);\n        this.number = indicatorJSON.number;\n        this.old_number = indicatorJSON.old_number;\n        this.name = indicatorJSON.name;\n        this.unitOfMeasure = indicatorJSON.unitOfMeasure;\n        this.directionOfChange = indicatorJSON.directionOfChange;\n        this.is_cumulative = indicatorJSON.is_cumulative;\n        this.unitType = indicatorJSON.unitType;\n        this.baseline = indicatorJSON.baseline;\n        this.baseline_na = this.baseline === null ? true : indicatorJSON.baseline_na;\n        this.typePks = indicatorJSON.indicatorTypes.map(indicatorType => parseInt(indicatorType.pk));\n        this.sitePks = indicatorJSON.sites.map(site => parseInt(site.pk));\n        this.sectorPk = (indicatorJSON.sector && indicatorJSON.sector.pk && parseInt(indicatorJSON.sector.pk));\n        this.lopTarget = parseFloat(indicatorJSON.lopTarget);\n        this.lopActual = parseFloat(indicatorJSON.lopActual);\n        this.lopMet = (indicatorJSON.lopMet && !isNaN(parseFloat(indicatorJSON.lopMet))) ?\n                        parseFloat(indicatorJSON.lopMet)*100 : null;\n        this.frequency = parseInt(indicatorJSON.frequency);\n        this.loadReportData(indicatorJSON.reportData);\n        this.sortIndex = parseInt(indicatorJSON.sortIndex);\n        this.levelpk = parseInt(indicatorJSON.levelpk) || null;\n        this.program = program;\n    }\n    \n    loadReportData(reportJSON) {\n        if (reportJSON.timeperiods) {\n            Object.keys(reportJSON.timeperiods)\n                .forEach(frequency => {\n                    this.reportData[TIMEPERIODS][frequency] = reportJSON.timeperiods[frequency].map(\n                        result => parseFloat(result)\n                    )});\n        }\n        if (reportJSON.tva) {\n            Object.keys(reportJSON.tva)\n                .forEach(frequency => {\n                    this.reportData[TVA][frequency] = reportJSON.tva[frequency].map(\n                        resultSet => ({\n                            target: parseFloat(resultSet.target),\n                            actual: parseFloat(resultSet.value),\n                            met: (\n                            ((resultSet.target && !isNaN(parseFloat(resultSet.target))) &&\n                             (resultSet.value && !isNaN(parseFloat(resultSet.value)) &&\n                              parseFloat(resultSet.target) != 0)) ?\n                                    parseFloat(resultSet.value)/parseFloat(resultSet.target) * 100 : null\n                                 )\n                                 })\n                    )\n                })\n        }\n    }\n    \n    get level() {\n        return this.program.getLevel(this.levelpk);\n    }\n    \n    get levelName() {\n        return this.level ? (this.level.old ? this.level.displayName : this.level.name) : null;\n    }\n    \n    get cumulative() {\n        return this.is_cumulative;\n    }\n\n}\n\nclass Level {\n    program = null;\n    pk = null;\n    name = null;\n    displayName = null;\n    _sort = null;\n\n    constructor(levelJSON, program) {\n        this.program = program;\n        this.pk = parseInt(levelJSON.pk);\n        this.name = levelJSON.name;\n        this.displayName = levelJSON.display_name;\n        this._sort = parseInt(levelJSON.sort);\n    }\n    \n    @computed get indicators() {\n        return this.program.indicators.filter(indicator => indicator.levelpk == this.pk);\n    }\n\n}\n\nclass OldLevel extends Level {\n    old = true;\n    @computed get sort() {\n        return this._sort;\n    }\n}\n\nclass NewLevel extends Level {\n    old = false;\n    tierPk = null;\n    ontology = null;\n    sortOntology = null;\n    depth = null;\n    _level2parent = null;\n    _parent = null;\n    \n    constructor(levelJSON, program) {\n        super(levelJSON, program);\n        this.tierPk = parseInt(levelJSON.tierPk);\n        this.ontology = levelJSON.ontology;\n        this.sortOntology = levelJSON.sort_ontology;\n        this.depth = parseInt(levelJSON.depth);\n        this._level2parent = parseInt(levelJSON.level2parent);\n        this._parent = parseInt(levelJSON.parent);\n    }\n    \n    get tier() {\n        return this.program.getTier(this.tierPk);\n    }\n    \n    get outcomeChainDisplay() {\n        var subLevelText = gettext('and sub-levels:');\n        return `${this.tier.name} ${this.sortDisplay} ${subLevelText}: ${this.name}`;\n    }\n    \n    get childLevels() {\n        return this.program.levels.filter(level => level._parent == this.pk);\n    }\n    \n    @computed get sort() {\n        return this.sortOntology || this._sort;\n    }\n    \n    @computed get sortDisplay() {\n        return this._sort;\n    }\n}\n\nclass Tier {\n    program = null;\n    pk = null;\n    name = null;\n    depth = null;\n    constructor(levelJSON, program) {\n        this.program = program;\n        this.pk = parseInt(levelJSON.tierPk);\n        this.name = levelJSON.tier;\n        this.depth = parseInt(levelJSON.depth);\n    }\n    \n    @computed get levels() {\n        return this.program.levels.filter(level => level.tierPk == this.pk);\n    }\n    \n}\n\n\nclass Period {\n    index = null;\n    start = null;\n    end = null;\n    current = null;\n    name = null;\n    display = null;\n    range = null;\n    constructor(periodJSON, index, frequency) {\n        this.index = index;\n        this.start = new Date(periodJSON[5]);\n        this.end = new Date(periodJSON[6]);\n        this.startDisplay = periodJSON[0];\n        this.endDisplay = periodJSON[1];\n        if (TIME_AWARE_FREQUENCIES.includes(frequency)) {\n            this.current = frequency === 7 ?\n                periodJSON.length > 4 && (periodJSON[4] === true || periodJSON[4] === \"True\") :\n                periodJSON.length > 2 && (periodJSON[2] === true || periodJSON[2] === \"True\");\n            switch (frequency) {\n                case 3:\n                    this.name = `${_gettext('Year')} ${index + 1}`;\n                    this.range = `${periodJSON[0]} - ${periodJSON[1]}`;\n                    this.display = `${this.name} (${this.range})`;\n                    break;\n                case 4:\n                    this.name = `${_gettext('Semi-annual period')} ${index + 1}`;\n                    this.range = `${periodJSON[0]} - ${periodJSON[1]}`;\n                    this.display = `${this.name} (${this.range})`;\n                    break;\n                case 5:\n                    this.name = `${_gettext('Tri-annual period')} ${index+1}`;\n                    this.range = `${periodJSON[0]} - ${periodJSON[1]}`;\n                    this.display = `${this.name} (${this.range})`;\n                    break;\n                case 6:\n                    this.name = `${_gettext('Quarter')} ${index+1}`;\n                    this.range = `${periodJSON[0]} - ${periodJSON[1]})`;\n                    this.display = `${this.name} (${this.range})`;\n                    break;\n                case 7:\n                    this.name = `${periodJSON[2]} ${periodJSON[3]}`;\n                    this.range = false;\n                    this.display = this.name;\n                    break;\n            }\n        }\n        if (frequency === 2 || frequency === 8) {\n            this.name = periodJSON[2];\n        }\n    }\n\n    startAfter(date) {\n        if (this.start.getUTCFullYear() < date.getUTCFullYear()) {\n            return false;\n        } else if (this.start.getUTCFullYear() > date.getUTCFullYear()) {\n            return true;\n        } else if (this.start.getUTCMonth() < date.getUTCMonth()) {\n            return false;\n        } else if (this.start.getUTCMonth() > date.getUTCMonth()) {\n            return true;\n        } else if (this.start.getUTCDate() < date.getUTCDate()) {\n            return false;\n        }\n        return true;\n    }\n    \n    endBefore(date) {\n        if (this.end.getUTCFullYear() > date.getUTCFullYear()) {\n            return false;\n        } else if (this.end.getUTCFullYear() < date.getUTCFullYear()) {\n            return true;\n        } else if (this.end.getUTCMonth() > date.getUTCMonth()) {\n            return false;\n        } else if (this.end.getUTCMonth() < date.getUTCMonth()) {\n            return true;\n        } else if (this.end.getUTCDate() > date.getUTCDate()) {\n            return false;\n        }\n        return true;\n    }\n    \n    get year() {\n        return this.start.getUTCFullYear();\n    }\n}\n\nclass PeriodRange {\n    frequency = null;\n    periods = [];\n    constructor(frequency, periodsJSON) {\n        this.frequency = parseInt(frequency);\n        this.periods = periodsJSON.map((periodJSON, index) => new Period(periodJSON, index, this.frequency));\n    }\n    \n    get currentPeriods() {\n        return this.periods.filter(period => !period.current);\n    }\n    \n    periodRange(startPeriod, endPeriod) {\n        return this.periods.slice(startPeriod, endPeriod + 1);\n    }\n    \n    startAfter(date) {\n        return this.periods.filter(period => period.startAfter(date));\n    }\n    \n    endBefore(date) {\n        return this.periods.filter(period => period.endBefore(date));\n    }\n    \n    filter(filterFn) {\n        return this.periods.filter(filterFn);\n    }\n    \n    getPeriod = ({\n        startAfter = null,\n        endBefore = null,\n        current = null,\n        last = null,\n        index = null\n        } = {}) => {\n        if (startAfter !== null) {\n            return this.startAfter(startAfter)[0];\n        } else if (endBefore !== null) {\n            return this.endBefore(endBefore).slice(-1)[0];\n        } else if (current !== null) {\n            return this.currentPeriods.slice(-1)[0];\n        } else if (last !== null) {\n            return this.periods.slice(-1)[0];\n        } else if (index !== null) {\n            return this.periods[index];\n        }\n    }\n}\n\nclass Program {\n    @observable pk = null;\n    @observable name = null;\n    @observable reportingStart = null;\n    @observable reportingEnd = null;\n    @observable frequencies = [];\n    @observable validTVA = false;\n    @observable validTIMEPERIODS = true;\n    @observable periods = {};\n    @observable oldLevels = false;\n    @observable _resultChainFilterLabel = null;\n    @observable _shortResultChainLabel = null;\n    @observable initialized = {\n        [TVA]: [],\n        [TIMEPERIODS]: []\n    };\n    @observable calls = {\n        [TVA]: {},\n        [TIMEPERIODS]: {}\n    };\n    @observable _levels = {};\n    @observable _tiers = {};\n    @observable _sites = {};\n    @observable _sectors = {};\n    @observable _types = {};\n    @observable _indicators = {};\n\n    constructor(JSON) {\n        this.pk = parseInt(JSON.id);\n        this.name = JSON.name;\n        this.frequencies = JSON.frequencies.map(Number);\n        this.reportingStart = JSON.reporting_period_start;\n        this.reportingEnd = JSON.reporting_period_end;\n        this.validTVA = this.frequencies.length > 0;\n        this.validTIMEPERIODS = true;\n        this.oldLevels = JSON.old_style_levels === true || JSON.old_style_levels === \"True\";\n        this._resultChainFilterLabel = JSON.result_chain_filter_label;\n        this._shortResultChainLabel = JSON.short_result_chain_label;\n        Object.entries(JSON.periodDateRanges)\n            .forEach(([frequency, periodsJSON]) => {\n                this.periods[parseInt(frequency)] = new PeriodRange(frequency, periodsJSON);\n            });\n    }\n    \n    getIndicator = ( indicatorPk ) => {\n        if (this._indicators[indicatorPk] && this._indicators[indicatorPk] !== undefined) {\n            return this._indicators[indicatorPk];\n        }\n        return {};\n    }\n    \n    updateProgramData = ( reportJSON ) => {\n        this.addLevels(reportJSON.levels);\n        if (reportJSON.indicators && Array.isArray(reportJSON.indicators)) {\n            reportJSON.indicators.forEach(indicatorJSON => {\n                let indicatorPk = parseInt(indicatorJSON.pk);\n                if (indicatorJSON.sector && indicatorJSON.sector.pk) {\n                    let sectorPk = parseInt(indicatorJSON.sector.pk);\n                    if (this._sectors[sectorPk] === undefined) {\n                        this._sectors[sectorPk] = {\n                            pk: sectorPk,\n                            name: indicatorJSON.sector.name || ''\n                        };\n                    }\n                }\n                if (indicatorJSON.sites && Array.isArray(indicatorJSON.sites)) {\n                    indicatorJSON.sites.forEach(siteJSON => {\n                        let sitePk = parseInt(siteJSON.pk);\n                        if (this._sites[sitePk] === undefined) {\n                            this._sites[sitePk] =  {\n                                pk: sitePk,\n                                name: siteJSON.name\n                            };\n                        }\n                    });\n                }\n                if (indicatorJSON.indicatorTypes && Array.isArray(indicatorJSON.indicatorTypes)) {\n                    indicatorJSON.indicatorTypes.forEach(typeJSON => {\n                        let typePk = parseInt(typeJSON.pk);\n                        if (this._types[typePk] === undefined) {\n                            this._types[typePk] = {\n                                pk: typePk,\n                                name: typeJSON.name\n                            };\n                        }\n                    });\n                }\n            });\n        }\n    }\n    \n    loadReportData = ( reportJSON ) => {\n        this.updateProgramData(reportJSON);\n        if (reportJSON.indicators && Array.isArray(reportJSON.indicators)) {\n           reportJSON.indicators.forEach(indicatorJSON => {\n                let indicatorPk = parseInt(indicatorJSON.pk);\n                if (this._indicators[indicatorPk] && this._indicators[indicatorPk].pk === indicatorPk) {\n                    this._indicators[indicatorPk].loadReportData(indicatorJSON.reportData);\n                } else {\n                    this._indicators[indicatorPk] = new Indicator(indicatorJSON, this);\n                }\n            });\n        }\n        this.initialized[parseInt(reportJSON.reportType)].push(parseInt(reportJSON.reportFrequency));\n        this.calls[parseInt(reportJSON.reportType)][parseInt(reportJSON.reportFrequency)] = false;\n    }\n    \n    loadIndicatorData = ( reportJSON ) => {\n        this.updateProgramData(reportJSON)\n        if (reportJSON.indicator) {\n            let indicatorPk = parseInt(reportJSON.indicator.pk);\n            if (this._indicators[indicatorPk]) {\n                delete this._indicators[indicatorPk];\n            }\n            this._indicators[indicatorPk] = new Indicator(reportJSON.indicator, this);\n            return Promise.resolve(indicatorPk);\n        } else {\n            return Promise.reject(STATUS_CODES.NO_INDICATOR_IN_UPDATE)\n        }\n    }\n    \n    validFrequency = ( frequency ) => {\n        return this.frequencies.includes(frequency);\n    }\n    \n    periodsFor =  ( frequency ) => {\n        return this.periods[parseInt(frequency)];\n    }\n    \n    currentPeriod = ( frequency ) => {\n        return this.periodsFor(frequency).getPeriod({current: true});\n    }\n    \n    lastPeriod = ( frequency ) => {\n        return this.periodsFor(frequency).getPeriod({last: true});\n    }\n    \n    isLoaded = ( reportType, frequency ) => {\n        return this.initialized[reportType].includes(frequency);\n    }\n    \n    isLoading = ( reportType, frequency ) => {\n        let loadingValue = this.calls[reportType][frequency];\n        if (loadingValue === undefined || loadingValue === false) {\n            return false;\n        }\n        return loadingValue;\n    }\n    \n    setLoading = ( reportType, frequency, call ) => {\n        this.calls[reportType][frequency] = call;\n    }\n    \n    addLevels = ( levelsJSON ) => {\n        if (!this.oldLevels) {\n            levelsJSON.forEach(levelJSON => {\n                let levelPk = parseInt(levelJSON.pk);\n                if (!isNaN(levelPk)) {\n                    this._levels[levelPk] = new NewLevel(levelJSON, this);\n                    let tierPk = parseInt(levelJSON.tierPk);\n                    if (!isNaN(tierPk)) {\n                        if (!this._tiers[tierPk]) {\n                            this._tiers[tierPk] = new Tier(levelJSON, this);\n                        }\n                    }\n                }\n            });\n        } else {\n            levelsJSON.forEach(levelJSON => {\n                let levelPk = parseInt(levelJSON.pk);\n                if (!isNaN(levelPk)) {\n                    this._levels[levelPk] = new OldLevel(levelJSON, this);\n                }\n            });\n        }\n    }\n    \n    getLevel = ( pk ) => {\n        pk = parseInt(pk);\n        return this._levels[pk] !== undefined ? this._levels[pk] : null;\n    }\n    \n    getTier = ( pk ) => {\n        pk = parseInt(pk);\n        return this._tiers[pk] !== undefined ? this._tiers[pk] : null;\n    }\n    \n    @computed get levels() {\n        return this._levels && Object.values(this._levels);\n    }\n    \n    @computed get tiers() {\n        return !this.oldLevels && this._tiers && Object.values(this._tiers).sort((x, y) => x.depth - y.depth);\n    }\n    \n    @computed get resultChainFilterLabel() {\n        return this._resultChainFilterLabel || (this.tiers && this.tiers.length > 1 && `by ${this.tiers[1].name} chain`);\n    }\n    \n    @computed get shortResultChainLabel() {\n        return this._shortResultChainLabel || (this.tiers && this.tiers.length > 1 && `${this.tiers[1].name} chains`);\n    }\n    \n    @computed get types() {\n        return this._types && Object.values(this._types);\n    }\n    \n    @computed get sectors() {\n        return this._sectors && Object.values(this._sectors);\n    }\n    \n    @computed get sites() {\n        return this._sites && Object.values(this._sites);\n    }\n    \n    @computed get indicators() {\n        return this._indicators && Object.values(this._indicators);\n    }\n    \n    @computed get unassignedIndicators() {\n        return this.indicators.filter(indicator => indicator.level === null)\n    }\n    \n    validLevel = (level) => this._levels[level] !== undefined\n    \n    validTier = (tier) => !this.oldLevels && this._tiers[tier] !== undefined;\n    \n    validType = (type) => this._types[type] !== undefined;\n    \n    validSite = (site) => this._sites[site] !== undefined;\n    \n    validSector = (sector) => this._sectors[sector] !== undefined;\n    \n    validIndicator = (indicator) => this._indicators[indicator] !== undefined;\n    \n    @computed get programPageUrl() {\n        return `/program/${this.pk}/`;\n    }\n    \n}\n\n/* Export for testing: */\nexport { Program, PeriodRange, Period };\n\nexport default class ProgramStore {\n    @observable _programs = {};\n    api = null;\n\n    constructor(contextData, api) {\n        this.api = api;\n        this.addPrograms(contextData.programs);\n        if (contextData.reportData !== undefined) {\n            this.getProgram( parseInt(contextData.reportData.programId) )\n                .loadReportData(contextData.reportData);\n        }\n    }\n\n    /**\n     * used at init - runs through program JSON and stores validated JSON data as program objects\n     */\n    addPrograms = (programsJSON) => {\n        programsJSON.forEach((programJSON) => {\n            this.addProgram(programJSON);\n        });\n    }\n    \n    /**\n     * stores one program's JSON data as a new program object\n     */\n    addProgram = (programJSON) => {\n        this._programs[programJSON.id] = new Program(programJSON);\n    }\n    \n    @computed get programs() {\n        return Object.values(this._programs).sort(this.sortByName);\n    }\n    \n    /**\n     * returns a validator function for the specified report type to check ids for validity against\n     */\n    validProgramId = ( reportType ) => {\n        return (id) => this.programs.filter(reportType === TVA ? program => program.validTVA : program => program.validTIMEPERIODS)\n            .map(program => program.pk)\n            .includes(id);\n    }\n\n    /**\n     * Return all program objects for a given report type\n     */\n    getPrograms = ( reportType ) => {\n        return this.programs.filter(reportType === TVA ? program => program.validTVA : program=>program.validTIMEPERIODS);\n    }\n\n    getProgram = ( id ) => {\n        return this._programs[id];\n    }\n    \n    loadProgram = ( reportType, id, frequency ) => {\n        if (this.getProgram(id).isLoaded(reportType, frequency)) {\n            return Promise.resolve(this.getProgram(id));\n        } else if (this.getProgram(id).isLoading(reportType, frequency) !== false) {\n            return Promise.resolve(this.getProgram(id).isLoading(reportType, frequency));\n        }\n        const dataHandler = this.getProgram(id).loadReportData;\n        let call = this.api.callForReportData( reportType, id, frequency )\n                    .then(dataHandler);\n        this.getProgram(id).setLoading(reportType, frequency, call);\n        return call;\n    }\n    \n    getLoadedProgram = ( reportType, id, frequency ) => {\n        return this.loadProgram(reportType, id, frequency).then(() => this.getProgram(id));\n    }\n\n    sortByName = ( programA, programB ) => {\n        return programA.name > programB.name ? 1\n                    : programB.name < programA.name ? -1\n                        : 0;\n    }\n    \n    @action\n    updateIndicator = ( reportType, programId, frequencyId, indicatorId ) => {\n        let program = this.getProgram(programId) || null;\n        if (program) {\n            let call = this.api.callForIndicatorData( reportType, programId, frequencyId, indicatorId )\n                        .then(program.loadIndicatorData).then(\n                            (pk) => {\n                                //do something with the pk here?  It updated!\n                                },\n                            (code) => {\n                                //do something with the failure here?\n                                }\n                        );\n            return call;\n        }\n    }\n    \n    @action\n    removeIndicator = ( programId, indicatorId ) => {\n        let program = this.getProgram(programId) || null;\n        if (program && program._indicators[indicatorId]) {\n            delete program._indicators[indicatorId];\n            return true;\n        }\n        return false;\n    }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { inject, observer } from 'mobx-react';\nimport { BootstrapPopoverButton } from '../../../../components/helpPopover';\n\nclass PinPopover extends React.Component {\n    NOT_SENT = 0;\n    SENDING = 1;\n    SENT = 2;\n    FAILED = 3;\n    constructor(props) {\n        super(props);\n        this.state = {\n            reportName: '',\n            status: this.NOT_SENT\n        };\n    }\n    handleChange = (e) => {\n        this.setState({reportName: e.target.value});\n    }\n    isDisabled = () => {\n        return !this.props.routeStore.pinData || !this.state.reportName;\n    }\n    handleClick = () => {\n        this.setState({status: this.SENDING});\n        $.ajax({\n            type: \"POST\",\n            url: this.props.routeStore.pinUrl,\n            data: {name: this.state.reportName, ...this.props.routeStore.pinData },\n            success: () => {\n                this.setState({status: this.SENT});\n                this.props.updatePosition();\n            },\n            error: (ev) => {\n                this.setState({status: this.FAILED});\n                console.log(\"ajax error:\", ev);\n                }\n        });\n    }\n    render() {\n        return (\n            <React.Fragment>\n            {(() => {\n            switch(this.state.status) {\n                case this.SENT:\n                    return (\n                        <div className=\"form-group\">\n                            <p><span>\n\n                                {/* # Translators: The user has successfully \"pinned\" a report link to a program page for quick access to the report */}\n                                {gettext('Success!  This report is now pinned to the program page')}\n\n                            </span></p>\n                            <p><a href={ this.props.filterStore.programPageUrl }>\n\n                                    {/* # Translators: This is not really an imperative, it's an option that is available once you have pinned a report to a certain web page */}\n                                    {gettext('Visit the program page now.')}\n\n                            </a></p>\n                        </div>\n                    );\n                case this.FAILED:\n                    return (\n                        <div className=\"form-group\">\n                            <p><span>\n                                {\n                                    gettext('Something went wrong when attempting to pin this report')\n                                }\n                            </span></p>\n                        </div>\n                    );\n                case this.NOT_SENT:\n                    return (\n                        <React.Fragment>\n                            <div className=\"form-group\">\n                                <label className=\"\">\n                                    {\n                                        /* # Translators: a field where users can name their newly created report */\n                                        gettext('Report name')\n                                    }\n                                </label>\n                                <input type=\"text\" className=\"form-control\"\n                                     value={ this.state.reportName }\n                                     onChange={ this.handleChange }\n                                     disabled={ this.state.sending }/>\n                            </div>\n                            <button type=\"button\"\n                                      onClick={ this.handleClick }\n                                      disabled={ this.isDisabled() }\n                                      className=\"btn btn-primary btn-block\">\n                                        {\n                                            gettext('Pin to program page')\n                                        }\n                            </button>\n                        </React.Fragment>\n                    );\n                case this.SENDING:\n                    return (\n                        <div className=\"btn btn-primary\" disabled>\n                            <img src='/static/img/ajax-loader.gif' />&nbsp;\n                                { gettext('Sending') }\n                        </div>\n                    );\n                }\n            })()}\n            </React.Fragment>\n        );\n    }\n}\n\n\n@inject('filterStore', 'routeStore')\nexport class PinButton extends BootstrapPopoverButton {\n    popoverName = 'pin';\n\n    getPopoverContent = () => {\n        return (\n            <PinPopover\n                filterStore={this.props.filterStore}\n                routeStore={this.props.routeStore}\n                updatePosition={() => {$(this.refs.target).popover('update');}}\n            />\n            );\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <button\n                    href=\"#\"\n                    className=\"btn btn-sm btn-secondary\"\n                    ref=\"target\">\n                <i className=\"fas fa-thumbtack\"></i>\n                    {\n                        /* # Translators: a button that lets a user \"pin\" (verb) a report to their home page */\n                        gettext('Pin')\n                    }\n                </button>\n            </React.Fragment>\n        );\n    }\n}\n\n\n@observer\nclass ExcelPopover extends React.Component {\n    getCurrent = () => {\n        if (this.props.routeStore.excelUrl) {\n            window.open(this.props.routeStore.excelUrl, '_blank');\n        }\n    }\n\n    getAll = () => {\n        if (this.props.routeStore.fullExcelUrl) {\n            window.open(this.props.routeStore.fullExcelUrl, '_blank');\n        }\n    }\n    render() {\n        return (\n            <div>\n                <button type=\"button\" className=\"btn btn-primary btn-block\" onClick={ this.getCurrent }>\n                    {\n                        /* # Translators: a download button for a report containing just the data currently displayed */\n                        gettext('Current view')\n                    }\n                </button>\n                <button type=\"button\" className=\"btn btn-primary btn-block\" onClick={ this.getAll }>\n                    {\n                        /* # Translators: a download button for a report containing all available data */\n                        gettext('All program data')\n                    }\n                </button>\n            </div>\n        );\n    }\n}\n\n@inject('filterStore', 'routeStore')\n@observer\nexport class ExcelPopoverButton extends BootstrapPopoverButton {\n    popoverName = 'excel';\n\n    getPopoverContent = () => {\n        return (\n            <ExcelPopover\n                filterStore={this.props.filterStore}\n                routeStore={this.props.routeStore} />\n            );\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <button type=\"button\"\n                     className=\"btn btn-sm btn-secondary\"\n                     ref=\"target\">\n                     <i className=\"fas fa-download\"></i> Excel\n                     </button>\n            </React.Fragment>\n        );\n    }\n}\n\n\n@inject('routeStore')\n@observer\nexport class ExcelButton extends React.Component {\n     handleClick = () => {\n        if (this.props.routeStore.excelUrl) {\n            window.open(this.props.routeStore.excelUrl, '_blank');\n        }\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <button type=\"button\"\n                     className=\"btn btn-sm btn-secondary\"\n                     onClick={this.handleClick }>\n                     <i className=\"fas fa-download\"></i> Excel\n                     </button>\n            </React.Fragment>\n        );\n    }\n}\n","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport {BLANK_TABLE_CELL} from '../../../../constants';\n\nfunction ipttRound(value, percent) {\n    if (value == gettext('N/A')) {\n        return value;\n    }\n    if (value !== '' && !isNaN(parseFloat(value))) {\n        if (!Number.isInteger(value)) {\n            value = Number.parseFloat(value).toFixed(2);\n            value = value.endsWith('00') ? parseInt(value) : value.endsWith('0') ? value.slice(0, -1) : value;\n        } else {\n            value = String(value);\n        }\n        return percent === true ? `${value}%` : value;\n    }\n    return null;\n}\n\nconst IndicatorEditModalCell = inject('filterStore')(\n    ({ filterStore, indicator }) => {\n        const loadModal = (e) => {\n            e.preventDefault();\n            let url = `/indicators/indicator_update/${indicator.pk}/?modal=true`;\n            $(\"#indicator_modal_content\").empty();\n            $(\"#modalmessages\").empty();\n            $(\"#indicator_modal_content\").load(url);\n            $(\"#indicator_modal_div\").modal('show')\n                .on('updated.tola.indicator.save', filterStore.indicatorUpdate)\n                .on('deleted.tola.indicator.save', filterStore.indicatorDelete)\n                .one('hidden.bs.modal', (ev) => {\n                    $(ev.target).off('.tola.save');\n                });\n        }\n        return (\n            <td className=\"td-no-side-borders\">\n                <button type=\"button\" className=\"btn btn-link p-1 float-right\"\n                        onClick={ loadModal }>\n                    <i className=\"fas fa-cog\"></i>\n                </button>\n            </td>\n        );\n    }\n    );\n\nconst IndicatorResultModalCell = ({ indicator }) => {\n    const loadModal = (e) => {\n        e.preventDefault();\n        let url = `/indicators/result_table/${indicator.pk}/0/?edit=false`;\n        $(\"#indicator_modal_content\").empty();\n        $(\"#modalmessages\").empty();\n        $(\"#indicator_modal_content\").load(url);\n        $(\"#indicator_modal_div\").modal('show');\n    }\n    return (\n        <td className=\"td-no-side-borders\">\n            <button type=\"button\" className=\"btn btn-link p-1 indicator-ajax-popup indicator-data\"\n                    onClick={ loadModal }>\n                <i className=\"fas fa-table\"></i>\n            </button>\n            { indicator.name }\n        </td>\n    )\n}\n\nconst IndicatorCell = ({ value, resultCell, ...props }) => {\n    const displayValue = (value || value === 0) ? value : BLANK_TABLE_CELL;\n    if (resultCell && resultCell === true) {\n        return <td { ...props }>{ displayValue }</td>;\n    }\n    return (\n        <td className=\"td-no-side-borders\" { ...props }>{ displayValue }</td>\n    );\n}\n\n\nconst PercentCell = ({ value, ...props }) => {\n    value = ipttRound(value, true);\n    return <IndicatorCell value={ value } align=\"right\" { ...props } />;\n}\n\nconst NumberCell = ({ value, ...props }) => {\n    value = ipttRound(value, false);\n    return <IndicatorCell value={ value } align=\"right\" { ...props } />;\n}\n\nconst TVAResultsGroup = ({ value, resultCell, ...props }) => {\n    return (\n        <React.Fragment>\n            <NumberCell value={ value.target } />\n            <NumberCell value={ value.actual } />\n            <PercentCell value={ value.met }/>\n        </React.Fragment>\n    );\n}\n\nconst TVAResultsGroupPercent = ({ value, resultCell, ...props }) => {\n    return (\n        <React.Fragment>\n            <PercentCell value={ value.target } />\n            <PercentCell value={ value.actual } />\n            <PercentCell value={ value.met }/>\n        </React.Fragment>\n    );\n}\n\nconst IndicatorRow = inject('reportStore')(\n    observer(({ reportStore, indicator, levelCol }) => {\n        var ValueCell;\n        var PeriodCell;\n        if (indicator.unitType == '%') {\n            ValueCell = PercentCell;\n            PeriodCell = reportStore.isTVA ? TVAResultsGroupPercent : PercentCell;\n        } else {\n            ValueCell = NumberCell;\n            PeriodCell = reportStore.isTVA ? TVAResultsGroup : NumberCell;\n        }\n        let cumulative = indicator.cumulative === null ? null\n                : indicator.cumulative ? gettext('Cumulative')\n                            : gettext('Non-cumulative');\n        let displayNumber = indicator.number;\n        if (displayNumber && displayNumber.length > 0 && displayNumber.slice(-1) == \":\") {\n            displayNumber = displayNumber.slice(0, -1);\n        }\n        return (\n            <tr>\n                <IndicatorCell value={ displayNumber } />\n                <IndicatorResultModalCell indicator={ indicator } />\n                <IndicatorEditModalCell indicator={ indicator } />\n                { levelCol && <IndicatorCell value={ indicator.levelName } /> }\n                <IndicatorCell value={ indicator.unitOfMeasure } />\n                <IndicatorCell value={ indicator.directionOfChange || gettext('N/A') } align=\"center\" />\n                <IndicatorCell value={ cumulative || gettext('N/A') } />\n                <IndicatorCell value={ indicator.unitType } align=\"center\" />\n                { indicator.baseline_na ? <IndicatorCell value={ gettext('N/A') } align=\"right\"/> : <ValueCell value={ indicator.baseline } /> }\n                <ValueCell value={ indicator.lopTarget } />\n                <ValueCell value={ indicator.lopActual } />\n                <PercentCell value={ indicator.lopMet } />\n                {\n                    reportStore.periodValues(indicator).map(\n                        (value, index) => <PeriodCell value={ value } key={ index } resultCell={ true }/>\n                    )\n                }\n\n            </tr>\n        );\n    })\n);\n\nconst LevelTitleRow = inject('reportStore')(\n    observer(({ reportStore, children }) => {\n        return (\n            <tr>\n            <td colSpan={ reportStore.reportWidth }\n                className=\"iptt-level-row\"\n            >\n               { children }\n            </td>\n            </tr>\n        )\n    })\n);\n\nconst LevelRow = ({ level }) => {\n    return (\n        <LevelTitleRow>\n             { level.tier.name }{ level.ontology ? ` ${level.ontology}` : '' }: { level.name }\n        </LevelTitleRow>\n    )\n}\n\nconst BlankLevelRow = () => {\n    return (\n        <LevelTitleRow>\n        {\n            gettext('Indicators unassigned to a results framework level')\n        }\n        </LevelTitleRow>\n    )\n}\n\nconst LevelGroup = ({ level, indicators }) => {\n    return (\n        <React.Fragment>\n            {\n                level ? <LevelRow level={ level } />\n                      : (indicators && indicators.length > 0) && <BlankLevelRow />\n            }\n            {\n                indicators.map(\n                    (indicator, index) => (\n                        <IndicatorRow indicator={ indicator }\n                                      levelCol={ false }\n                                      key={ index } />\n                                      )\n                )\n            }\n        </React.Fragment>\n    );\n}\n\n\nexport { LevelGroup, IndicatorRow };\n","import React from 'react';\nimport Select from 'react-select';\nimport ReactMultiSelectCheckboxes from 'react-multiselect-checkboxes';\nimport { uniqueId } from '../formUtils';\nimport { GROUP_BY_CHAIN, GROUP_BY_LEVEL } from '../constants';\n\n\n\nexport const SingleReactSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let labelClasses = props.labelClasses || \"col-form-label text-uppercase\";\n    let formRowClasses = props.formRowClasses || \"form-row mb-3\";\n    let selectClasses = props.selectClasses || \"tola-react-select\";\n    return (\n        <div className={ formRowClasses }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClasses }>\n                    { props.label }\n            </label>\n            <Select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClasses }\n                isDisabled={ props.disabled }\n                options={ props.options }\n            />\n        </div>\n    );\n}\n\nexport const DateSelect = ( props ) => {\n    let selectId = uniqueId('date-select');\n    let formattedOptions =\n        (props.options && props.options.length == 1 && props.options[0].value !== undefined) ?\n            <option value={ props.options[0].value }>{ props.options[0].label }</option> :\n            (props.options && props.options.length > 0 && props.options[0].options && props.options[0].options !== undefined) ?\n                props.options.map(\n                    (optgroup, index) => {\n                        return <optgroup label={ optgroup.label } key={ index }>\n                                    {optgroup.options.map(\n                                        option => (<option value={ option.value } key={ option.value }>\n                                                        { option.label }\n                                                   </option>)\n                                        )\n                                    }\n                                </optgroup>\n                        }) :\n                props.options.map(\n                    (option, index) => {\n                        return <option value={ option.value } key={ index }>{ option.label }</option>;\n                    }\n                );\n\n    return (\n        <div className=\"form-row mb-3\">\n            <label\n                htmlFor={ selectId }\n                className=\"col-form-label text-uppercase\">\n                    { props.label }\n            </label>\n            <select\n                className=\"form-control\"\n                id={ selectId }\n                value={ props.value }\n                onChange = { props.update }\n                disabled = { props.disabled }>\n                { formattedOptions }\n            </select>\n        </div>\n    );\n}\n\nexport const SingleSelect = ( props ) => {\n    let selectId = uniqueId('react-select');\n    let formGroupClass = props.formGroupClass || \"form-row mb-3\";\n    let labelClass = props.labelClass || \"col-form-label text-uppercase\";\n    let selectClass = props.selectClass || \"form-control\";\n    return (\n        <div className={ formGroupClass }>\n            <label\n                htmlFor={ selectId }\n                className={ labelClass }>\n                    { props.label }\n            </label>\n            <select\n                onChange={ props.update }\n                value={ props.value }\n                id={ selectId }\n                className={ selectClass }\n                disabled={ props.disabled }>\n                { props.options }\n            </select>\n        </div>\n    );\n}\n\n\n/**\n * styling element to replace OptGroup headings in react multiselect checkbox widgets - used for\n * MultiSelectCheckbox when optgroups are required\n */\nconst GroupHeading = (props) => {\n    if (props.children == '') {\n        return <div></div>;\n    } else {\n        return (\n            <React.Fragment>\n                <hr style={{ margin: '3px 0px 0px 0px' }} />\n                <div className=\"text-muted\"\n                     style={{ textTransform: 'uppercase',\n                              paddingLeft: '4px',\n                              marginBottom: '2px'}}>\n                    { props.children }\n                </div>\n            </React.Fragment>\n            );\n    }\n}\n\n\n/**\n * Styles ReactMultiSelectCheckbox to fit Tola styles\n */\nexport const MultiSelectCheckbox = ( props ) => {\n    const selectId = uniqueId('multiselect');\n    const multiSelectProps = (!props.options || props.options.length == 0) ?\n            {\n                getDropdownButtonLabel: () => gettext('None available'),\n                isDisabled: true,\n                menuIsOpen: false,\n                options: [],\n            } :\n            {\n                isMulti: true,\n                options: props.options,\n                getDropdownButtonLabel: (_ref) => {\n                    if (!_ref.value) {\n                        return gettext('None selected');\n                    }\n                    if (Array.isArray(_ref.value)) {\n                        if (_ref.value.length == 0) {\n                            return gettext('None selected');\n                        }\n                        if (_ref.value.length == 1) {\n                            return _ref.value[0].label;\n                        }\n                        return `${_ref.value.length}  ${gettext('selected')}`;\n                    }\n                    return _ref.value.label;\n                }\n            };\n    const baseStyles = {\n        dropdownButton: base => (!props.options || props.options.length == 0)\n                            ? { ...base, backgroundColor: '#E5E6E8', background: '' }\n                            : base,\n        option: (provided, state) => ({\n                ...provided,\n                padding: '1px 12px',\n                display: 'inline-block'\n            }),\n        container: (provided, state) => ({\n                ...provided,\n                backgroundColor: '#f5f5f5'\n            }),\n    };\n    const formatOptionLabel = (props) => {\n        return <div style={{ display: \"inline-block\" , float: \"right\", width: \"90%\"}}>{props.label}</div>;\n    };\n    return (\n        <div className=\"form-row mb-2 tola-react-multiselect-row\">\n            <label htmlFor={ selectId } className=\"col-form-label text-uppercase\">\n                { props.label }\n            </label>\n            <ReactMultiSelectCheckboxes\n                id={ selectId }\n                styles={ baseStyles }\n                formatOptionLabel = { formatOptionLabel }\n                components={{ GroupHeading }}\n                value={ props.value }\n                onChange={ props.update }\n                { ...multiSelectProps }\n            />\n        </div>\n    );\n}\n\nexport const GroupBySelect = ({ chainLabel, ...selectProps }) => {\n    let options = [\n        <option value={ GROUP_BY_CHAIN } key={1}>{ chainLabel }</option>,\n        <option value={ GROUP_BY_LEVEL } key={2}>{\n            /* # Translators: refers to grouping the report by the level of the indicator */\n            gettext('by Level')\n        }</option>\n    ];;\n    return <SingleSelect\n                label={\n                    /* # Translators: menu for selecting how rows are grouped in a report */\n                    gettext('Group indicators')\n                }\n                options={ options }\n                { ...selectProps }\n            />;\n}\n","/*\n * ID generating code &c. for form inputs\n */\n\nlet lastId = 0;\n\nexport function uniqueId (prefix='id') {\n    lastId++;\n    return `${prefix}${lastId}`;\n}","import React from 'react';\nimport { observer, inject } from 'mobx-react';\nimport { MultiSelectCheckbox } from '../../../../components/selectWidgets';\n\n\n/**\n * input-ready multi-select checkbox widget for filtering IPTT report by level\n * contains both \"grouping\" and \"chaining\" filtering options, displayed as two optgroups\n * labeling for second optgroup is based on Program's definition of tier 2 (stored in rootStore.selectedProgram)\n */\nconst LevelSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        const updateSelected = (selected) => {\n            let levelSelects = selected.filter(option => option.filterType == 'level').map(option => option.value);\n            let tierSelects = selected.filter(option => option.filterType == 'tier').map(option => option.value);\n            if (levelSelects && levelSelects.length > 0 && tierSelects && tierSelects.length > 0) {\n                if (filterStore.levels.length == levelSelects.length) {\n                    filterStore.tiers = tierSelects;\n                } else {\n                    filterStore.levels = levelSelects;\n                }\n            } else if (levelSelects && levelSelects.length > 0) {\n                filterStore.levels = levelSelects;\n            } else if (tierSelects && tierSelects.length > 0) {\n                filterStore.tiers = tierSelects;\n            } else {\n                filterStore.levels = [];\n                filterStore.tiers = [];\n            }\n        };\n        return <MultiSelectCheckbox\n                    label={ gettext('Levels') }\n                    options={ filterStore.levelOptions }\n                    value={\n                        filterStore.levels && filterStore.levels.length > 0 ?\n                            filterStore.levelsSelected :\n                        filterStore.tiers && filterStore.tiers.length > 0 ?\n                            filterStore.tiersSelected :\n                            []\n                    }\n                    update={ updateSelected }\n                />;\n    })\n);\n\n/**\n * multi-select checkbox for selecting sites for filtering IPTT */\nconst SiteSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels sites that a data could be collected at */\n                        gettext('Sites')\n                    }\n                    options={ filterStore.siteOptions }\n                    value={ filterStore.sitesSelected }\n                    update={ selected => {filterStore.sites = selected.map(s => s.value);} }\n                />;\n    })\n);\n\n\n/**\n * multi-select checkbox for selecting types for filtering IPTT */\nconst TypeSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels types of indicators to filter by */\n                        gettext('Types')\n                    }\n                    options={ filterStore.typeOptions }\n                    value={ filterStore.typesSelected }\n                    update={ selected => {filterStore.types = selected.map(s => s.value);} }\n                />;\n    })\n);\n\n\n/**\n * multi-select checkbox for selecting sectors for filtering IPTT */\nconst SectorSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels sectors (i.e. 'Food Security') that an indicator can be categorized as */\n                        gettext('Sectors')\n                    }\n                    options={ filterStore.sectorOptions }\n                    value={ filterStore.sectorsSelected }\n                    update={ selected => {filterStore.sectors = selected.map(s => s.value);} }\n                />;\n    })\n);\n\n\n/**\n * multi-select checkbox for selecting indicators for filtering IPTT */\nconst IndicatorSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <MultiSelectCheckbox\n                    label={\n                        /* # Translators: labels a filter to select which indicators to display */\n                        gettext('Indicators')\n                    }\n                    options={ filterStore.indicatorOptions }\n                    value={ filterStore.indicatorsSelected }\n                    update={ selected => {filterStore.indicators = selected.map(s => s.value);} }\n                />;\n    })\n);\nexport { LevelSelect, SiteSelect, TypeSelect, SectorSelect, IndicatorSelect };","import React from 'react';\nimport IPTTHeader from './header';\nimport IPTTTable from './table';\n\nconst IPTTReport = () => {\n    return <main className=\"iptt_table_wrapper\">\n                <div id=\"id_div_top_iptt_report\">\n                    <IPTTHeader />\n                    <IPTTTable />\n                </div>\n            </main>;\n                \n}\n\nexport default IPTTReport;","import { observable, action, computed, reaction } from 'mobx';\nimport {\n    TVA,\n    TIMEPERIODS,\n    GROUP_BY_CHAIN,\n    GROUP_BY_LEVEL,\n    BLANK_OPTION,\n    TIME_AWARE_FREQUENCIES,\n    getPeriodLabels\n} from '../../../constants';\n\nimport { flattenArray, ensureNumericArray } from '../../../general_utilities';\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nconst {targetperiodLabels, timeperiodLabels } = getPeriodLabels();\n\nexport default class FilterStore {\n    programStore = null;\n    @observable _reportType = null;\n    @observable _programId = null;\n    @observable _frequencyId = null;\n    @observable _startPeriod = null;\n    @observable _endPeriod = null;\n    @observable _groupBy = null;\n    @observable _levels = [];\n    @observable _tiers = [];\n    @observable _sites = [];\n    @observable _sectors = [];\n    @observable _types = [];\n    @observable _indicators = [];\n    @observable _latchMostRecent = false;\n    _oldShowAll = null;\n    _oldMostRecent = null;\n    \n\n    constructor(programStore) {\n        this.programStore = programStore;\n        const reportChange = reaction(\n            () => this.frequencyId !== null && [this.reportType, this.programId, this.frequencyId],\n            (reportParams) => {this._reportParamsUpdated(reportParams);}\n        );\n    }\n\n    set reportType(reportType) {\n        reportType = parseInt(reportType);\n        if (reportType && [TVA, TIMEPERIODS].includes(reportType)) {\n            this._reportType = reportType;\n        } else {\n            this._reportType = null;\n        }\n    }\n\n    @computed get reportType() {\n        return this._reportType;\n    }\n    \n    @computed get isTVA() {\n        return this.reportType === TVA;\n    }\n    \n    /* returns a function which will check program IDs for validity given the report type:\n     * - for timeperiods: does the program exist and have indicators\n     * - for tva: does the program exist and have indicators in TVA frequencies\n     */\n    @computed get _validProgramId() {\n        return this.programStore.validProgramId(this._reportType);\n    }\n    \n    set programId(programId) {\n        programId = parseInt(programId);\n        if (this._validProgramId(programId)) {\n            this.updateTransitionParams()\n            this._programId = programId;\n        }\n    }\n    \n    @computed get programId() {\n        return this._programId;\n    }\n    \n    @computed get program() {\n        if (this._programId !== null) {\n            return this.programStore.getProgram(this._programId);\n        }\n        return null;\n    }\n    \n    /* Whether the frequency selector is disabled */\n    @computed get frequencyDisabled() {\n        return !(this.program !== null);\n    }\n\n    /* Internally checks if frequency is valid selection before saving\n     *  - must be time-aware for Timeperiods report\n     *  - must be a valid frequency for the program for TVA report\n     */\n    _validFrequency = (frequencyId) => {\n        if (frequencyId && this.program) {\n            if (this.isTVA) {\n                return this.program.validFrequency(frequencyId);\n            } else {\n                return TIME_AWARE_FREQUENCIES.includes(frequencyId);\n            }\n        }\n        return false;\n    }\n    \n    set frequencyId(frequencyId) {\n        frequencyId = parseInt(frequencyId);\n        if (this._validFrequency(frequencyId)) {\n            this.updateTransitionParams()\n            this._frequencyId = frequencyId;\n        }\n    }\n    \n    @computed get frequencyId() {\n        if (this._frequencyId) {\n            return this._frequencyId;\n        }\n        return null;\n    }\n    \n    /* Returns a promise to be completed after programStore loads the program from the API call\n     * promise will immediately complete if the program is already loaded\n     */\n    getLoadedProgram() {\n        this.updateTransitionParams();\n        if (this.reportType && this.program && this.frequencyId) {\n            return this.programStore.getLoadedProgram(\n                this.reportType, this.programId, this.frequencyId\n            );\n        } else {\n            return Promise.reject(false);\n        }\n    }\n    \n    @computed get programIsLoaded() {\n        if (this.frequencyId) {\n            return this.program.isLoaded(this.reportType, this.frequencyId);\n        }\n        return false;\n    }\n    \n    updateTransitionParams() {\n        this._oldShowAll = this.showAll;\n        this._oldMostRecent = this.mostRecent;\n        this._latchMostRecent = false;\n    }\n    \n    clearTransitionParams() {\n        this._oldShowAll = null;\n        this._oldMostRecent = null;\n    }\n    \n    get oldShowAll() {\n        return this._oldShowAll;\n    }\n    \n    get oldMostRecent() {\n        return this._oldMostRecent;\n    }\n    \n    \n    /* Action to take (as a reaction) when report type, program id, or frequencyid change\n     * contains logic for:\n     *  - updating the program in the programstore (including api call if necessary)\n     *  - making sure the new frequency is valid (and if not replacing with one that is)\n     *  - updating start and end periods to make sense in the new frequency\n     *  - clearing indicator filters\n     */\n    @action _reportParamsUpdated([reportType, programId, frequencyId]) {\n        this.programStore.loadProgram(reportType, programId, frequencyId)\n            .then(() => {\n                const showAll = this.oldShowAll;\n                const mostRecent = this.oldMostRecent;\n                this.clearTransitionParams();\n                this.frequencyId = this.frequencyId || null;\n                if (!this._validFrequency(frequencyId)) {\n                    this.frequencyId = this.isTVA ?\n                        this.program.frequencies[0] :\n                        TIME_AWARE_FREQUENCIES[0];\n                    this.showAll = true;\n                }\n                if (showAll) {\n                    this.showAll = true;\n                } else if (mostRecent !== false) {\n                    this.mostRecent = mostRecent;\n                } else {\n                    this.startPeriod = this.startPeriod || 0;\n                    this.endPeriod = this.endPeriod || this.lastPeriod.index;\n                }\n                if (this.reportType === TVA && this.indicators && this.indicators.length > 0) {\n                    this.indicators = [];\n                }\n            });\n    }\n\n    /* Whether the start and end period selectors are enabled */    \n    @computed get periodsDisabled() {\n        let ret = !(TIME_AWARE_FREQUENCIES.includes(this.frequencyId));\n        return ret;\n    }\n    \n    /* Returns all periods for the given program and frequency\n     *   Note this returns a PeriodRange (see ./programStore.js for details)\n     */\n    @computed get periods() {\n        if (this.frequencyId && this.frequencyId !== 1) {\n            return this.program.periodsFor(this.frequencyId);\n        }\n        return null;\n    }\n\n    /* Returns the last period for the current program/frequency (for setting end) */\n    @computed get lastPeriod() {\n        if (this.frequencyId) {\n            return this.program.lastPeriod(this.frequencyId);\n        }\n        return null;\n    }\n\n    /* \"Current\" here means most recently completed (for calculating most recent x periods) */\n    @computed get currentPeriod() {\n        if (this.frequencyId) {\n            return this.program.currentPeriod(this.frequencyId);\n        }\n        return null;\n    }\n    \n    set startPeriod(startPeriod) {\n        if (this.lastPeriod !== null) {\n            this._startPeriod = Math.max(0, Math.min(this.lastPeriod.index, startPeriod));\n            this._latchMostRecent = false;\n            if (this.endPeriod && this._startPeriod > this.endPeriod) {\n                this.endPeriod = startPeriod;\n            }\n        }\n    }\n    \n    @computed get startPeriod() {\n        if (!this.periodsDisabled && this.lastPeriod !== null && this._startPeriod <= this.lastPeriod.index) {\n            return this._startPeriod;\n        }\n        return null;\n    }\n    \n    set endPeriod(endPeriod) {\n        if (this.lastPeriod !== null) {\n            this._endPeriod = Math.max((this.startPeriod || 0), Math.min(this.lastPeriod.index, endPeriod));\n            this._latchMostRecent = false;\n        }\n    }\n    \n    @computed get endPeriod() {\n        if (!this.periodsDisabled && this.lastPeriod !== null && this._endPeriod <= this.lastPeriod.index) {\n            return this._endPeriod;\n        }\n        return null;\n    }\n    \n    set showAll(showAll) {\n        if (showAll === true && this.lastPeriod) {\n            this.startPeriod = 0;\n            this.endPeriod = this.lastPeriod.index;\n            this._latchMostRecent = false;\n        }\n    }\n    \n    @computed get _internalShowAll() {\n        return (\n            this.startPeriod === 0 && this.lastPeriod && this.endPeriod === this.lastPeriod.index\n            );\n    }\n    \n    @computed get showAll() {\n        return (\n            !this._latchMostRecent && this._internalShowAll\n            );\n    }\n    \n    set mostRecent(count) {\n        if (this.currentPeriod) {\n            this.endPeriod = this.currentPeriod.index;\n            this.startPeriod = Math.max(0, this.currentPeriod.index - (parseInt(count) || 2) + 1);\n            this._latchMostRecent = this._internalShowAll;\n        }\n    }\n    \n    @computed get mostRecent() {\n        if (!this.showAll && this.currentPeriod && this.endPeriod === this.currentPeriod.index) {\n            return this.currentPeriod.index - this.startPeriod + 1;\n        }\n        return false;\n    }\n\n    /* Added so that the most recent display can bypass show-all logic and display a value */\n    @computed get _mostRecentValue() {\n        if (this.currentPeriod && this.endPeriod === this.currentPeriod.index) {\n            return this.currentPeriod.index - this.startPeriod + 1;\n        }\n        return false;\n    }\n    \n    setStartPeriodFromDate(dateObj) {\n        if (this.periods) {\n            this.startPeriod = this.periods.getPeriod({startAfter: dateObj}).index;\n        }\n        return null;\n    }\n    \n    setEndPeriodFromDate(dateObj) {\n        if (this.periods) {\n            this.endPeriod = this.periods.getPeriod({endBefore: dateObj}).index;\n        }\n        return null;\n    }\n    \n    /* whether the program is using old-style (non-satsuma) levels */\n    @computed get oldLevels() {\n        if (this.program !== null) {\n            return this.program.oldLevels;\n        }\n        return null;\n    }\n\n    @computed get groupByDisabled() {\n        return this.oldLevels !== false;\n    }\n    \n    set groupBy(groupBy) {\n        if ([GROUP_BY_CHAIN, GROUP_BY_LEVEL].includes(parseInt(groupBy))) {\n            this._groupBy = parseInt(groupBy);\n        }\n    }\n    \n    @computed get groupBy() {\n        if (!this.groupByDisabled) {\n            return this._groupBy || GROUP_BY_CHAIN;\n        }\n        return null;\n    }\n    \n    @computed get resultChainFilterLabel() {\n        return this.program.resultChainFilterLabel;\n    }\n    \n    /* whether the lower-half filters (which filter visible indicators) are enabled\n     * Logic: they are enabled when the program is fully loaded for this frequency\n     */\n    @computed get filtersDisabled() {\n        return !(this.programIsLoaded);\n    }\n    \n    /* Levels = old-style levels (assigned pk manually in views_reports.py)\n     * or new style levels (specific rf level items, i.e. Output 1.1) by pk\n     */\n    set levels(levels) {\n        if (!this.filtersDisabled && ensureNumericArray(levels)) {\n            this._levels = ensureNumericArray(levels);\n            this._tiers = [];\n        } else {\n            this._levels = [];\n        }\n    }\n    \n    @computed get levels() {\n        if (!this.filtersDisabled && this._levels && this._levels.length > 0) {\n            return this._levels.filter(this.program.validLevel);\n        }\n        return [];\n    }\n    \n    /* Tiers: only for new style levels, the leveltier (i.e. Outcome) */\n    set tiers(tiers) {\n        if (!this.filtersDisabled && !this.groupByDisabled && ensureNumericArray(tiers)) {\n            this._tiers = ensureNumericArray(tiers);\n            this._levels = [];\n        } else {\n            this._tiers = [];\n        }\n    }\n    \n    @computed get tiers() {\n        if (!this.filtersDisabled && this._tiers &&\n            this._tiers.length > 0 && !this.groupByDisabled) {\n            return this._tiers.filter(this.program.validTier);\n        }\n        return [];\n    }\n    \n    set sites(sites) {\n        if (!this.filtersDisabled && ensureNumericArray(sites)) {\n            this._sites = ensureNumericArray(sites);\n        } else {\n            this._sites = [];\n        }\n    }\n    \n    @computed get sites() {\n        if (!this.filtersDisabled && this._sites && this._sites.length > 0) {\n            return this._sites.filter(this.program.validSite);\n        }\n        return [];\n    }\n    \n    /* \"Types\" as in Indicator Types (i.e. Custom/donor) */\n    set types(types) {\n        if (!this.filtersDisabled && ensureNumericArray(types)) {\n            this._types = ensureNumericArray(types);\n        } else {\n            this._types = [];\n        }\n    }\n    \n    @computed get types() {\n        if (!this.filtersDisabled && this._types && this._types.length > 0) {\n            return this._types.filter(this.program.validType);\n        }\n        return [];\n    }\n    \n    set sectors(sectors) {\n        if (!this.filtersDisabled && ensureNumericArray(sectors)) {\n            this._sectors = ensureNumericArray(sectors);\n        } else {\n            this._sectors = [];\n        }\n    }\n    \n    @computed get sectors() {\n        if (!this.filtersDisabled && this._sectors && this._sectors.length > 0) {\n            return this._sectors.filter(this.program.validSector);\n        }\n        return [];\n    }\n    \n    /* setting indicator PKs for filtering ( show only those indicators) */\n    set indicators(indicators) {\n        if (!this.filtersDisabled && ensureNumericArray(indicators)) {\n            this._indicators = ensureNumericArray(indicators);\n        } else {\n            this._indicators = [];\n        }\n    }\n    \n    @computed get indicators() {\n        if (!this.filtersDisabled && this._indicators && this._indicators.length > 0) {\n            return this._indicators.filter(this.program.validIndicator);\n        }\n        return [];\n    }\n    \n    /** OPTION providers for select widgets: ******/\n    \n    \n    @computed get programOptions() {\n        let programs = this.reportType && this.programStore.getPrograms(this.reportType);\n        return (programs && programs.length > 0)\n                    ? programs.map(program => ({value: program.pk, label: program.name}))\n                    : [BLANK_OPTION];\n    }\n    \n    @computed get selectedProgramOption() {\n        if (this.program) {\n            return {\n                value: this.programId,\n                label: this.program.name\n            };\n        }\n        return null;\n    }\n    \n    @computed get frequencyOptions() {\n        if (this.program && this.reportType === TIMEPERIODS) {\n            return TIME_AWARE_FREQUENCIES.map(pk => ({value: pk, label: timeperiodLabels[pk]}));\n        } else if (this.program && this.reportType === TVA) {\n            return this.program.frequencies.filter(pk => pk !== 8)\n                .map(pk => ({value: pk, label: targetperiodLabels[pk]}));\n        } else {\n            return [BLANK_OPTION];\n        }\n    }\n    \n     @computed get selectedFrequencyOption() {\n        if (this.frequencyId) {\n            return {\n                value: this.frequencyId,\n                label: this.isTVA ? targetperiodLabels[this.frequencyId]\n                                : timeperiodLabels[this.frequencyId]\n            };\n        } else {\n            return BLANK_OPTION;\n        }\n    }\n\n    _getPeriodOptions(periodFilter) {\n        if (!this.frequencyId || !TIME_AWARE_FREQUENCIES.includes(this.frequencyId)) {\n            return [BLANK_OPTION];\n        } else if (this.frequencyId == 3) {\n            // years don't have year-based opt-groups:\n            return this.periods.filter(periodFilter).map(\n                period => ({label:period.display, value: period.index})\n            );\n        } else {\n            let periods = this.periods.filter(periodFilter);\n            // all non-annual time-aware frequencies are opt-grouped by year:\n            let years = Array.from(new Set(this.periods.filter(periodFilter)\n                                            .map(period => period.year))).filter(year => !isNaN(year)).sort();\n            return years.map(\n                year => {\n                    let options = periods.filter(period => period.year === year)\n                                    .map(period => ({label: period.display, value: period.index}));\n                    return {\n                        label: year,\n                        options: options\n                    };\n                });\n        }\n    }\n    \n    @computed get startOptions() {\n        return this._getPeriodOptions(() => true);\n    }\n    \n    /* Label for the date section under the title of the report */\n    @computed get startPeriodLabel() {\n        if (this.startPeriod !== null) {\n            return this.periods.getPeriod({index: this.startPeriod}).startDisplay;\n        }\n        if (this.frequencyId === 1 || this.frequencyId === 2) {\n            return this.program.reportingStart;\n        }\n        return null;\n    }\n    \n    @computed get endOptions() {\n        const periodFilter = (period) => period.index >= this.startPeriod;\n        return this._getPeriodOptions(periodFilter);\n    }\n    \n    /* Label for the date section under the title of the report */\n    @computed get endPeriodLabel() {\n        if (this.endPeriod !== null) {\n            return this.periods.getPeriod({index: this.endPeriod}).endDisplay;\n        }\n        if (this.frequencyId === 1 || this.frequencyId === 2) {\n            return this.program.reportingEnd;\n        }\n        return null;\n    }\n    \n    \n    @computed get levelOptions() {\n        if (!this.filtersDisabled && this.groupByDisabled) {\n            // old-style (non-RF) levels:\n            let availableLevels = this.levels.concat(\n                this.filterIndicators(this.program.indicators, 'levels').map(\n                    indicator => indicator.level ? indicator.level.pk : null\n            ));\n            return this.program.levels.filter(\n                    level => availableLevels.includes(level.pk)\n                ).sort((x, y) => x.pk - y.pk)\n                .map(level => ({value: level.pk, label: level.name, filterType: 'level'}));\n        } else if (!this.filtersDisabled) {\n            // new style levels and leveltiers:\n            let availableTiers = this.tiers.concat(\n                this.filterIndicators(this.program.indicators, 'levels').map(\n                    indicator => indicator.level ? indicator.level.tierPk : null\n            ));\n            let tiers = this.program.tiers.filter(\n                tier => availableTiers.includes(tier.pk)\n            );\n            let availableLevels = flattenArray(this.levels.concat(\n                this.filterIndicators(this.program.indicators, 'levels').map(\n                    indicator => indicator.level ? [indicator.level.pk, indicator.level._level2parent] : []\n                )\n            ));\n            let levels = this.program.levels.filter(\n                level => availableLevels.includes(level.pk)\n            );\n            let options = [];\n            if (tiers && tiers.length > 0) {\n                options.push({\n                    label: '',\n                    options: tiers.sort((x, y) => x.depth - y.depth)\n                                .map(tier => ({value: tier.pk, label: tier.name, filterType: 'tier'}))\n                });\n            }\n            if (levels && levels.length > 0) {\n                options.push({\n                    label: this.program.shortResultChainLabel,\n                    options: levels.filter(\n                        level => level.tier.depth == 2\n                    ).map(\n                        level => ({value: level.pk, label: level.outcomeChainDisplay, filterType: 'level'})\n                    )\n                });\n            }\n            return options;\n        }\n        return null;\n    }\n    \n    @computed get levelsSelected() {\n        if (this.levels && this.levels.length > 0) {\n            return this.program.levels.filter(level => this.levels.includes(level.pk))\n                    .map(level => ({value: level.pk, label: level.name, filterType: 'level'}));\n        }\n        return [];\n    }\n    \n    @computed get tiersSelected() {\n        if (this.tiers && this.tiers.length > 0) {\n            return this.program.tiers.filter(tier => this.tiers.includes(tier.pk))\n                    .map(tier => ({value: tier.pk, label: tier.name, filterType: 'tier'}));\n        }\n        return [];\n    }\n    \n    @computed get typeOptions() {\n        if (!this.filtersDisabled) {\n            let availableTypes = flattenArray(this.types.concat(this.filterIndicators(this.program.indicators, 'types').map(\n                indicator => indicator.typePks\n            )));\n            return this.program.types.filter(\n                iType => availableTypes.includes(iType.pk)\n            ).map(iType => ({value: iType.pk, label: iType.name}));\n        }\n        return null;\n    }\n    \n    @computed get typesSelected() {\n        if (this.types && this.types.length > 0) {\n            return this.typeOptions.filter(typeOpt => this.types.includes(typeOpt.value));\n        }\n        return [];\n    }\n    \n    @computed get sectorOptions() {\n        if (!this.filtersDisabled) {\n            let availableSectors = this.sectors.concat(\n                this.filterIndicators(this.program.indicators, 'sectors').map(\n                    indicator => indicator.sectorPk\n                )\n            );\n            return this.program.sectors.filter(\n                sector => availableSectors.includes(sector.pk)\n                ).map(sector => ({value: sector.pk, label: sector.name}));\n        }\n        return null;\n    }\n    \n     @computed get sectorsSelected() {\n        if (this.sectors && this.sectors.length > 0) {\n            return this.sectorOptions.filter(sector => this.sectors.includes(sector.value));\n        }\n        return [];\n    }\n    \n    @computed get siteOptions() {\n        if (!this.filtersDisabled) {\n            let availableSites = this.sites.concat(\n                flattenArray(this.filterIndicators(this.program.indicators, 'sites').map(\n                    indicator => indicator.sitePks\n                ))\n            );\n            return this.program.sites.filter(\n                site => availableSites.includes(site.pk)\n            ).map(site => ({value: site.pk, label: site.name}));\n        }\n        return null;\n    }\n    \n    @computed get sitesSelected() {\n        if (this.sites && this.sites.length > 0) {\n            return this.siteOptions.filter(site => this.sites.includes(site.value));\n        }\n        return [];\n    }\n    \n    @computed get indicatorOptions() {\n        if (!this.filtersDisabled) {\n            if (this.groupByDisabled) {\n                return this.filterIndicators(this.program.indicators, 'indicators')\n                    .map(indicator => ({value: indicator.pk, label: indicator.name}));\n            } else {\n                return this.filterLevels('indicators').map(\n                    level => ({\n                        label: `${level.tier.name} ${level.sortDisplay}`,\n                        options: this.filterIndicators(level.indicators, 'indicators').map(\n                            indicator => ({\n                                    value: indicator.pk,\n                                    label: `${indicator.number || ''} ${indicator.name}`\n                                })\n                        )\n                    })\n                ).concat([{\n                    label: gettext('Indicators unassigned to a results framework level'),\n                    options: this.filterIndicators(\n                        this.program.unassignedIndicators, 'indicators').map(\n                            indicator => ({value: indicator.pk, label: indicator.name}))\n                    }]).filter(({label, options}) => options && options.length > 0);\n            }\n        }\n        return [];\n    }\n    \n     @computed get indicatorsSelected() {\n        if (this.indicators && this.indicators.length > 0) {\n            let indicatorOptions = this.groupByDisabled ? this.indicatorOptions :\n                flattenArray(this.indicatorOptions.map(optgroup => optgroup.options));\n            return indicatorOptions.filter(indicator => this.indicators.includes(indicator.value));\n        }\n        return [];\n    }\n    \n    @action clearFilters = () => {\n        this.sectors = [];\n        this.types = [];\n        this.sites = [];\n        this.indicators = [];\n        this.levels = [];\n        this.tiers = [];\n    }\n    \n    /* whether this is in an unfiltered state */\n    @computed get noFilters() {\n        return (\n            (!this.indicators || this.indicators.length == 0) &&\n            (!this.types || this.types.length == 0) &&\n            (!this.levels || this.levels.length == 0) &&\n            (!this.tiers || this.tiers.length == 0) &&\n            (!this.sectors || this.sectors.length == 0) &&\n            (!this.sites || this.sites.length == 0)\n            );\n    }\n    \n    @computed get programPageUrl() {\n        if (this.program) {\n            return this.program.programPageUrl;\n        }\n        return false;\n    }\n    \n    @computed get filteredIndicators() {\n        return this.filterIndicators(this.program.indicators);\n    }\n    \n    filterIndicators(indicatorSet, skip = false) {\n        let indicators = indicatorSet.sort((a, b) => a.sortIndex - b.sortIndex);\n        if (this.groupByDisabled) {\n            indicators = indicators.sort((a, b) => {\n                if (a.levelpk && b.levelpk) {\n                    if (a.levelpk != b.levelpk) {\n                        return (a.levelpk < b.levelpk) ? -1 \n                                : (b.levelpk < a.levelpk) ? 1 : 0;\n                    } else if (a.old_number && b.old_number) {\n                        return (a.old_number < b.old_number) ? -1\n                            : (b.old_number < a.old_number) ? 1 : 0;\n                    } else if (a.old_number) {\n                        return -1;\n                    } else if (b.old_numbeR) {\n                        return 1;\n                    }\n                    return 0;\n                } else if (a.levelpk) {\n                    return -1;\n                } else if (b.levelpk) {\n                    return 1;\n                } \n                return 0;\n            });\n        }\n        \n        if (this.reportType === TVA) {\n            indicators = indicators.filter(\n                indicator => indicator.frequency == this.frequencyId\n            );\n        }\n        if (skip !== 'indicators' && this.indicators && this.indicators.length > 0) {\n            indicators = indicators.filter(indicator => this.indicators.includes(indicator.pk));\n        }\n        if (skip !== 'types' && this.types && this.types.length > 0) {\n            indicators = indicators.filter(\n                indicator => (\n                    indicator.typePks.length > 0 &&\n                    indicator.typePks.filter(pk => this.types.includes(pk)).length > 0\n                )\n            );\n        }\n        if (skip !== 'sites' && this.sites && this.sites.length > 0) {\n            indicators = indicators.filter(\n                indicator => (\n                    indicator.sitePks.length > 0 &&\n                    indicator.sitePks.filter(pk => this.sites.includes(pk)).length > 0\n                )\n            );\n        }\n        if (skip !== 'sectors' && this.sectors && this.sectors.length > 0) {\n            indicators = indicators.filter(\n                indicator => indicator.sectorPk && this.sectors.includes(indicator.sectorPk)\n            );\n        }\n        if (skip !== 'levels' && this.levels && this.levels.length > 0) {\n            if (this.groupByDisabled) {\n                indicators = indicators.filter(\n                    indicator => indicator.level && this.levels.includes(indicator.levelpk)\n                );\n            } else {\n                indicators = indicators.filter(\n                  indicator => (\n                    indicator.level && (this.levels.includes(indicator.level.pk) ||\n                                        this.levels.includes(indicator.level._level2parent))\n                    )\n                );\n            }\n        } else if (skip !== 'levels' && this.tiers && this.tiers.length > 0) {\n            indicators = indicators.filter(\n                indicator => (\n                    indicator.level && indicator.level.tierPk && this.tiers.includes(indicator.level.tierPk)\n                )\n            )\n        }\n        return indicators || [];\n    }\n    \n    @computed get filteredLevels() {\n        return this.filterLevels(false);\n    }\n    \n    filterLevels(skip = false) {\n        var levels = false;\n        if (this.groupBy === GROUP_BY_LEVEL) {\n            levels = this.program.levels.sort(\n                (levela, levelb) => levela.sort - levelb.sort).sort(\n                (levela, levelb) => levela.depth - levelb.depth\n            )\n        } else if (this.groupBy === GROUP_BY_CHAIN) {\n            let parents = this.program.levels.filter(level => !level._parent);\n            levels = this._findChildren(parents, []);\n        }\n        if (levels) {\n            var levelPks;\n            if (skip) {\n                levelPks = new Set(this.filterIndicators(this.program.indicators, skip).map(indicator => indicator.levelpk));\n            } else {\n                levelPks = new Set(this.filteredIndicators.map(indicator => indicator.levelpk));\n            }\n            if ((this.levels && this.levels.length > 0) || (this.tiers && this.tiers.length > 0) || (this.indicators && this.indicators.length > 0)) {\n                levels = levels.filter(level => levelPks.has(level.pk));\n            } else {\n                levels = levels.filter(level => !level._parent || levelPks.has(level.pk));\n            }\n            if (levels.length == 1 && !levelPks.has(levels[0].pk)) {\n                return [];\n            }\n            return levels;\n        }\n        return [];\n    }\n    \n    _findChildren(parents) {\n        let levels = [];\n        for (let i = 0; i < parents.length; i++) {\n            levels.push(parents[i]);\n            if (parents[i].childLevels && parents[i].childLevels.length > 0) {\n                levels = levels.concat(this._findChildren(parents[i].childLevels));\n            }\n        }\n        return levels;\n    }\n    \n    @action\n    indicatorUpdate = (ev, {programId, indicatorId, ...params}) => {\n        if (programId && programId == this.programId) {\n            this.programStore.updateIndicator(\n                this.reportType, programId, this.frequencyId, indicatorId\n            );\n        }\n    }\n    \n    @action\n    indicatorDelete = (ev, {programId, indicatorId, ...params}) => {\n        if (programId && programId == this.programId) {\n            this.programStore.removeIndicator(programId, indicatorId);\n        }\n    }\n}","import React from 'react';\nimport IPTTFilterForm from './filterForm';\n\nconst IPTTSidebar = () => {\n    return (\n        <div className=\"sidebar_wrapper\">\n            <div className=\"collapse width show\" id=\"sidebar\">\n                <IPTTFilterForm />\n            </div>\n            <div className=\"sidebar-toggle\">\n              <a href=\"#\" data-target=\"#sidebar\" data-toggle=\"collapse\"\n                    title={\n                        /* # Translators: A toggle button that hides a sidebar of filter options */\n                        gettext('Show/Hide Filters') }>\n                <i className=\"fa fa-chevron-left\"></i>\n              </a>\n            </div>\n        </div>\n    );\n}\n\nexport default IPTTSidebar;","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport * as HeaderCells from './headerCells';\n\n\nconst ProgramNameRow = inject('reportStore')(\n    observer(({ reportStore }) => {\n        return (\n            <tr className=\"title-row\">\n                <td colSpan={ reportStore.levelColumn ? 9 : 8 } id=\"id_td_iptt_program_name\" className=\"align-bottom pt-2\">\n                    <h5 className=\"m-0\">\n                       { reportStore.programName }\n                    </h5>\n                </td>\n                <td scope=\"colgroup\" colSpan=\"3\"\n                    className=\"text-center title-row text-nowrap align-bottom text-uppercase\">\n                    {\n                        /* # Translators: header for a group of columns showing totals over the life of the program */\n                        gettext('Life of program')\n                    }\n                </td>\n                {\n                    reportStore.reportPeriods.map(\n                        (period, index) => (\n                            <HeaderCells.PeriodHeader isTVA={ reportStore.isTVA} key={ index }\n                                                      period={ period } />\n                        )\n                    )\n                }\n            </tr>\n        );\n    })\n);\n\nconst ColumnHeaderRow = inject('reportStore')(\n    observer(({ reportStore }) => {\n        return (\n            <tr>\n                <HeaderCells.BorderedHeader\n                    styleWidth={110}\n                    align=\"center\"\n                    label={\n                        /* # Translators: Abbreviation as column header for \"number\" column */\n                        gettext('No.')\n                    } />\n                <HeaderCells.UnBorderedHeader\n                    styleWidth={600}\n                    label={\n                        /* # Translators: Column header for indicator Name column */\n                        gettext('Indicator')\n                    } />\n                <HeaderCells.UnBorderedHeader />\n                { reportStore.levelColumn && <HeaderCells.BorderedHeader\n                    styleWidth={90}\n                    label={\n                        /* # Translators: Column header for indicator Level name column */\n                        gettext('Level')\n                    } />\n                }\n                <HeaderCells.BorderedHeader\n                    styleWidth={250}\n                    label={\n                        /* # Translators: Column header */\n                        gettext('Unit of measure')\n                    } />\n                <HeaderCells.BorderedHeader\n                    label={\n                        /* # Translators: Column header for \"direction of change\" column (increasing/decreasing) */\n                        gettext('Change')\n                    } />\n                <HeaderCells.BorderedHeader\n                    styleWidth={130}\n                    label={\n                        /* # Translators: Column header, stands for \"Cumulative\"/\"Non-cumulative\" */\n                        gettext('C / NC')\n                    } />\n                <HeaderCells.BorderedHeader\n                    styleWidth={50}\n                    label={\n                        /* # Translators: Column header, numeric or percentage type indicator */\n                        gettext('# / %')\n                    } />\n                <HeaderCells.BorderedHeader\n                    label={\n                        /* # Translators: Column header */\n                        gettext('Baseline')\n                    } />\n                <HeaderCells.TVAHeader />\n                { reportStore.reportPeriods.map(\n                    (period, index) => (reportStore.isTVA ?\n                                <HeaderCells.TVAHeader key={ index } /> :\n                                <HeaderCells.ActualHeader key={ index } />\n                              )\n                )}\n            </tr>\n        )\n    })\n);\n\nconst ReportTableHeader = () => {\n    return (\n        <thead className=\"thead-light\">\n            <ProgramNameRow />\n            <ColumnHeaderRow />\n        </thead>\n        );\n}\n\nexport default ReportTableHeader;","import React from 'react';\nimport { inject, observer } from 'mobx-react';\nimport * as Selectors from './reportSelect';\nimport * as Filters from './reportFilter';\nimport { IPTTButton } from './buttons';\n\n\nconst FilterTop = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <React.Fragment>\n                <Selectors.ProgramSelect />\n                <Selectors.FrequencySelect />\n                <Selectors.TimeframeRadio />\n                <Selectors.StartDateSelect />\n                <Selectors.EndDateSelect />\n                { (filterStore.oldLevels === false &&\n                   filterStore.resultChainFilterLabel !== false) &&\n                    <Selectors.GroupingSelect />\n                }\n            </React.Fragment>\n        );\n    })\n);\n\nconst FilterMiddle = () => {\n    return (\n        <React.Fragment>\n            <Filters.LevelSelect />\n            <Filters.SiteSelect />\n            <Filters.TypeSelect />\n            <Filters.SectorSelect />\n            <Filters.IndicatorSelect />\n        </React.Fragment>\n    );\n}\n\nconst IPTTFilterForm = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <nav id=\"id_iptt_report_filter\">\n                <div className=\"p-3\" id=\"filter-top\">\n                    <h3 className=\"filter-title text-title-case\">\n                        {\n                        /* # Translators: Labels a set of filters to select which data to show */\n                         gettext('Report Options') }\n                    </h3>\n                    <FilterTop />\n                </div>\n                <div id=\"filter-middle\" className=\"px-3 pt-3 pb-2\">\n                    <FilterMiddle />\n                </div>\n                <div id=\"filter-bottom\">\n                    <IPTTButton\n                        label={\n                            /* # Translators: clears all filters set on a report */\n                            gettext('Clear filters')\n                        }\n                        action={ filterStore.clearFilters }\n                        isDisabled={ filterStore.noFilters }\n                    />\n              </div>\n              <div id=\"filter-extra\" className=\" d-flex justify-content-between no-gutters p-3\">\n                  <a href={\"/tola_management/audit_log/\" + filterStore.programId}\n                      className=\"btn-link\">\n                      <i className=\"fas fa-history\"></i> {gettext(\"Change log\")}\n                  </a>\n              </div>\n            </nav>\n        );\n    })\n);\n\nexport default IPTTFilterForm;\n","function flattenArray(arr, depth = 1) {\n    if (depth == 5) {\n        return arr;\n    }\n    let flattened = [];\n    arr.forEach(item => {\n        if (Array.isArray(item)) {\n            flattened = flattened.concat(flattenArray(item, depth+1));\n        } else {\n            flattened.push(item);\n        }\n    });\n    return flattened;\n}\n\nfunction ensureNumericArray(value) {\n    if (!Array.isArray(value)) {\n        value = parseInt(value);\n        if (value && !isNaN(value)) {\n            return [value];\n        }\n        return false;\n    }\n    let arr = value.map(x => parseInt(x)).filter(x => !isNaN(x));\n    if (arr && Array.isArray(arr) && arr.length > 0) {\n        return arr;\n    }\n    return false;\n}\n\n/*\n * Are we loading a cached page? If so, reload to avoid displaying stale indicator data\n * See ticket #1423\n */\nfunction reloadPageIfCached() {\n    // moving the cache check to after page load as firefox calculates transfer size at the end\n    $(function () {\n        let isCached = window.performance.getEntriesByType(\"navigation\")[0].transferSize === 0;\n        //adding a second check to ensure that if for whatever reason teh transfersize reads wrong, we don't reload on\n        //a reload:\n        let isReload = window.performance.getEntriesByType(\"navigation\")[0].type === \"reload\";\n        if (isCached && !isReload) {\n            window.location.reload();\n        }\n    });\n}\n\nconst indicatorManualNumberSort = (levelFunc, numberFunc) => {\n    return (indicatorA, indicatorB) => {\n        let levelA = levelFunc(indicatorA);\n        let levelB = levelFunc(indicatorB);\n        if (levelA && !levelB) {\n            return 1;\n        }\n        if (levelB && !levelA) {\n            return -1;\n        }\n        if (levelA != levelB) {\n            return parseInt(levelA) - parseInt(levelB);\n        }\n        let numberA = (numberFunc(indicatorA) || '').split('.');\n        let numberB = (numberFunc(indicatorB) || '').split('.');\n        for (let i=0; i < Math.max(numberA.length, numberB.length); i++) {\n            if (numberA[i] && numberB[i]) {\n                for (let j=0; j < Math.max(numberA[i].length, numberB[i].length); j++) {\n                    if (numberA[i][j] && numberB[i][j]) {\n                        if (numberA[i].charCodeAt(j) != numberB[i].charCodeAt(j)) {\n                            return numberA[i].charCodeAt(j) - numberB[i].charCodeAt(j);\n                        }\n                    } else if (numberA[i][j]) {\n                        return 1;\n                    } else if (numberB[i][j]) {\n                        return -1;\n                    }\n                }\n            } else if (numberA[i]) {\n                return 1;\n            } else if (numberB[i]) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n}\n\nexport { flattenArray, ensureNumericArray, reloadPageIfCached, indicatorManualNumberSort };\n","import createRouter from 'router5';\nimport browserPlugin from 'router5-plugin-browser';\nimport { observable, computed, reaction } from 'mobx';\n\nimport { TVA, TIMEPERIODS, GROUP_BY_CHAIN, GROUP_BY_LEVEL } from '../../constants';\n\n\nexport default class ipttRouter {\n    filterStore = null;\n\n    constructor(filterStore, jsContext) {\n        if (jsContext && jsContext.pin_url) {\n            this.pinUrl = jsContext.pin_url;\n        }\n        this.routes = [\n        {\n            name: 'iptt',\n            path: '/iptt_report/:programId<\\\\d+>',\n            children: [\n                {\n                    name: 'timeperiods',\n                    path: '/timeperiods?timeperiods'\n                },\n                {\n                    name: 'tva',\n                    path: '/targetperiods?targetperiods'\n                }\n            ]\n        },\n        {\n            name: 'ipttAPI',\n            path: '/iptt_api?reportType&programId',\n            children: [\n                {\n                    name: 'ipttData',\n                    path: '/iptt_report_data/'\n                },\n                {\n                    name: 'ipttExcel',\n                    path: '/iptt_excel/?fullTVA'\n                }\n            ]\n        }\n    ];\n    this.goodQueryParams = ['frequency', 'start', 'end', 'levels', 'types', 'sites',    \n                            'sectors', 'indicators', 'tiers', 'groupby', 'mr'];\n    this.oldQueryParams = ['timeframe', 'numrecentperiods', 'numrecentcount', 'start_period', 'end_period'];\n    this.queryParams = '?' + (this.goodQueryParams.concat(this.oldQueryParams)).join('&');\n    this.filterStore = filterStore;\n    }\n    \n    init = () => {\n        this.router = createRouter(this.routes, {trailingSlashMode: 'always'});\n        this.router.setRootPath(this.queryParams);\n        this.router.usePlugin(browserPlugin({useHash: false, base: '/indicators'}));\n        this.router.start();\n        let { name: currentRouteName, params: currentRouteParams} = this.router.getState();\n        this.processParams({name: currentRouteName, ...currentRouteParams}).then(\n            () => {\n                if (this.router.buildPath(currentRouteName, currentRouteParams) !=\n                    this.router.buildPath(this.routeName, this.routeParams)) {\n                    this.router.navigate(this.routeName, this.routeParams, {replace: true});\n                }\n                const navigateWhenRouteChanges = reaction(\n                    () => [this.routeName, this.routeParams],\n                    ([name, params]) => this.router.navigate(name, params)\n                );\n            });\n        \n    }\n    \n    processParams = ({\n        name = null,\n        programId = null,\n        frequency = null,\n        start = null,\n        end = null,\n        mr = null,\n        timeperiods = null,\n        targetperiods = null,\n        timeframe = null,\n        numrecentcount = null,\n        numrecentperiods = null,\n        start_period = null,\n        end_period = null,\n        groupby = null,\n        levels = null,\n        tiers = null,\n        sites = null,\n        sectors = null,\n        types = null,\n        indicators = null\n        } = {}) => {\n        if (this.filterStore === null) {\n            throw \"data not loaded\";\n        }\n        this.filterStore.reportType = (name == 'iptt.tva') ? TVA\n                                    : (name == 'iptt.timeperiods') ? TIMEPERIODS\n                                    : null;\n        this.filterStore.programId = parseInt(programId);\n        if (frequency !== null) {\n            this.filterStore.frequencyId = parseInt(frequency);\n        } else if (this.reportType === TVA && targetperiods !== null) {\n            this.filterStore.frequencyId = parseInt(targetperiods);\n        } else if (this.reportType === TIMEPERIODS && timeperiods !== null) {\n            this.filterStore.frequencyId = parseInt(timeperiods);\n        }\n        if (start !== null) {\n            this.filterStore.startPeriod = parseInt(start);\n        } else if (start_period !== null && !isNaN(Date.parse(start_period))) {\n            this.filterStore.setStartPeriodFromDate(new Date(start_period));\n        }\n        if (end !== null) {\n            this.filterStore.endPeriod = parseInt(end);\n        } else if (end_period !== null && !isNaN(Date.parse(end_period))) {\n            this.filterStore.setEndPeriodFromDate(new Date(end_period));\n        }\n        if (mr !== null) {\n            this.filterStore._latchMostRecent = true;\n        }\n        if (timeframe !== null && parseInt(timeframe) == 1) {\n            this.filterStore.showAll = true;\n        } else if (timeframe !== null && parseInt(timeframe) == 2) {\n            this.filterStore.mostRecent = parseInt(numrecentperiods) || parseInt(numrecentcount) || 2;\n        }\n        if (groupby !== null && (parseInt(groupby) === GROUP_BY_CHAIN || parseInt(groupby) === GROUP_BY_LEVEL)) {\n            this.filterStore.groupBy = parseInt(groupby);\n        }\n        return this.filterStore.getLoadedProgram().then(() => {\n            if (levels !== null) {\n                tiers = null;\n                this.filterStore.levels = this.parseArrayParams(levels);\n            }\n            if (tiers !== null) {\n                this.filterStore.tiers = this.parseArrayParams(tiers);\n            }\n            if (types !== null) {\n                this.filterStore.types = this.parseArrayParams(types);\n            }\n            if (sites !== null) {\n                this.filterStore.sites = this.parseArrayParams(sites);\n            }\n            if (sectors !== null) {\n                this.filterStore.sectors = this.parseArrayParams(sectors);\n            }\n            if (indicators !== null) {\n                this.filterStore.indicators = this.parseArrayParams(indicators);\n            }\n            return true;\n        },\n        () => false);\n    }\n    \n    @computed get reportType() {\n        return this.filterStore.reportType;\n    }\n    \n    parseArrayParams = (param) => {\n        if (typeof param === 'string' || param instanceof String) {\n            return [parseInt(param)];\n        } else if (Array.isArray(param)) {\n            return param.map(p => parseInt(p));\n        } else if (Number.isInteger(param)) {\n            return param;\n        } else if (!isNaN(parseInt(param))) {\n            return [parseInt(param)];\n        }\n        return null;\n    }\n    \n    parseToArrayParams = (param) => {\n        if (Array.isArray(param)) {\n            return param.map(this.parseToArrayParams);\n        } else if (typeof param === 'string' || param instanceof String) {\n            return param;\n        }\n        return String(param);\n    }\n    \n    @computed get routeName() {\n        return this.reportType === TVA\n                    ? 'iptt.tva'\n                    : (this.reportType === TIMEPERIODS)\n                        ? 'iptt.timeperiods'\n                        : 'iptt';\n    }\n    \n    @computed get routeParams() {\n        let params = {};\n        let keys = [\n            'programId',\n            'levels',\n            'tiers',\n            'sectors',\n            'sites',\n            'types',\n            'indicators'];\n        keys.forEach((k) => {\n            if (this.filterStore[k] !== null)\n                {\n                    params[k] = this.parseToArrayParams(this.filterStore[k]);\n                }\n            });\n        if (this.filterStore.frequencyId !== null) {\n            params.frequency = String(this.filterStore.frequencyId);\n        }\n        if (this.filterStore.startPeriod !== null) {\n            params.start = String(this.filterStore.startPeriod);\n        }\n        if (this.filterStore.endPeriod !== null) {\n            params.end = String(this.filterStore.endPeriod);\n        }\n        if (this.filterStore.groupBy !== null) {\n            params.groupby = String(this.filterStore.groupBy);\n        }\n        return params;\n    }\n    \n    @computed get pinData() {\n        let {programId, ...params} = this.routeParams;\n        let reportType = this.reportType === TVA ? 'targetperiods'\n                : this.reportType === TIMEPERIODS ? 'timeperiods' : null;\n        let queryString = [];\n        Object.keys(params).forEach(\n            k => {\n                if (params[k]) {\n                    if (!Array.isArray(params[k])) {\n                        queryString.push([k, params[k]]);\n                    } else if (params[k].length == 1) {\n                        queryString.push([k, params[k][0]]);\n                    } else {\n                        params[k].forEach(\n                            v => {\n                                queryString.push([k, v]);\n                            }\n                        )\n                    }\n                }\n            }\n        );\n        if (this.filterStore._latchMostRecent && this.filterStore._internalShowAll) {\n            queryString.push(['mr',  1]);\n        }\n        return {\n            program: programId,\n            report_type: reportType,\n            query_string: queryString.map(([k, v]) => `${k}=${v}`).join('&')\n        };\n    }\n    \n    @computed get dataUrl() {\n        return this.router.buildUrl('ipttAPI.ipttData', this.routeParams);\n    }\n    \n    @computed get excelUrl() {\n        if (this.filterStore.frequencyId) {\n            \n            return this.router.buildUrl('ipttAPI.ipttExcel',\n                                         {...this.routeParams,\n                                         reportType: this.reportType,\n                                         fullTVA: false});\n        }\n        return false;\n    }\n\n    \n    @computed get fullExcelUrl() {\n        if (this.filterStore.isTVA && this.filterStore.programId) {\n            return this.router.buildUrl('ipttAPI.ipttExcel', {\n                                            programId: this.filterStore.programId,\n                                            fullTVA: true,\n                                            groupby: this.filterStore.groupBy\n                                        });\n        }\n        return false;\n    }\n\n}","import React from 'react';\n\nexport const IPTTButton = ( props ) => {\n    return (\n        <button type=\"reset\" className={ \"btn btn-block btn-reset\" + (props.isDisabled ? \" disabled\" : \"\")}\n             onClick={ props.action }>\n                { props.label }\n        </button>\n    );\n}","import React from 'react';\nimport ReportTableHeader from './tableHeader';\nimport ReportTableBody from './tableBody';\n\nconst IPTTTable = () => {\n    //return (\n    //    <table className=\"table table-sm table-bordered table-hover table__iptt\" id=\"iptt_table\">\n    //        <IPTTTableHead />\n    //        <IPTTTableBody />\n    //    </table>\n    //    );\n    return (\n        <table className=\"table table-sm table-bordered table-hover table__iptt\" id=\"iptt_table\">\n            <ReportTableHeader />\n            <ReportTableBody />\n        </table>\n        );\n}\nexport default IPTTTable;","import React from 'react';\nimport { observer, inject } from 'mobx-react';\n\nimport { LevelGroup, IndicatorRow } from './tableRows';\n\nconst ReportTableBody = inject('reportStore')(\n    observer(({ reportStore }) => {\n        return (\n        <tbody>\n            {\n                reportStore.levelRows ?\n                    reportStore.groupedIndicatorRows.map(\n                        ({level, indicators}, index) => (\n                            <LevelGroup level={ level } indicators={ indicators } key={ index } />\n                        )\n                    )\n                :\n                    reportStore.indicatorRows.map(\n                        (indicator, index) => (\n                            <IndicatorRow indicator={ indicator }\n                                          levelCol={ reportStore.levelColumn }\n                                          key={ index } />\n                        )\n                    )\n            }\n        </tbody>\n        );\n    })\n);\n\nexport default ReportTableBody;","/**\n * entry point for the iptt_report webpack bundle\n */\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'mobx-react';\nimport ipttRouter from './router';\nimport ReportAPI from './api';\nimport ProgramStore from './models/programStore';\nimport FilterStore from './models/filterStore';\nimport ReportStore from './models/reportStore';\nimport IPTTReportApp from './components/main';\n\nconst API = new ReportAPI(jsContext.api_url);\nconst dataStore = new ProgramStore(jsContext, API);\nconst filterStore = new FilterStore(dataStore);\nconst reportStore = new ReportStore(filterStore);\nconst routeStore = new ipttRouter(filterStore, jsContext);\nrouteStore.init();\n\n\nReactDOM.render(<Provider filterStore={ filterStore }\n                          routeStore={ routeStore }\n                          reportStore={ reportStore }>\n                    <IPTTReportApp />    \n                </Provider>,\n                document.querySelector('#id_div_content'));","import React from 'react';\nimport { observer, inject } from 'mobx-react';\nimport { PinButton, ExcelButton, ExcelPopoverButton } from './buttons';\n\n\nconst IPTTHeader = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <div className=\"page-subheader\">\n                    <div id=\"id_span_iptt_date_range\" className=\"subheader__title\">\n                        <h2 className=\"pt-3 text-title-case\">{\n                            gettext('Indicator Performance Tracking Table')\n                        }</h2>\n                        <h4 className=\"pb-3\">{ (filterStore.startPeriodLabel && filterStore.endPeriodLabel)\n                                               ? filterStore.startPeriodLabel + \" - \" + filterStore.endPeriodLabel\n                                               : \"\" }</h4>\n                    </div>\n                    <div className=\"subheader__actions\">\n                        <div className=\"btn-row\">\n                            <PinButton />\n                            {filterStore.isTVA ? <ExcelPopoverButton /> : <ExcelButton />}\n                        </div>\n                    </div>\n                </div>\n    })\n);\n\n\nexport default IPTTHeader;\n","import { observable, action, computed, reaction } from 'mobx';\nimport { TVA, TIMEPERIODS, GROUP_BY_CHAIN, GROUP_BY_LEVEL, BLANK_OPTION, TIME_AWARE_FREQUENCIES } from '../../../constants';\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\n\nexport default class ReportStore {\n    constructor(filterStore) {\n        this.filterStore = filterStore;\n    }\n    \n    @computed get isTVA() {\n        return this.filterStore.reportType === TVA;\n    }\n    \n    @computed get programName() {\n        if (this.filterStore.program) {\n            return this.filterStore.program.name;\n        }\n        return null;\n    }\n    \n    @computed get levelColumn() {\n        return this.filterStore.oldLevels === true;\n    }\n    \n    @computed get levelRows() {\n        return this.filterStore.oldLevels === false;\n    }\n    \n    @computed get reportPeriods() {\n        if (this.filterStore.periods) {\n            if (this.filterStore.frequencyId == 2) {\n                return this.filterStore.periods.periods;\n            }\n            return this.filterStore.periods.periodRange(this.filterStore.startPeriod, this.filterStore.endPeriod) || [];\n        }\n        return [];\n    }\n    \n    @computed get indicatorRows() {\n        if (this.levelRows) {\n            return [];\n        }\n        if (this.filterStore.frequencyId && this.filterStore.programIsLoaded) {\n            return this.filterStore.filteredIndicators || [];\n        }\n        return [];\n    }\n    \n    @computed get groupedIndicatorRows() {\n        if (!this.levelRows) {\n            return [];\n        }\n        if (this.filterStore.frequencyId && this.filterStore.programIsLoaded) {\n            return this.filterStore.filteredLevels.map(\n                level => ({\n                    level: level,\n                    indicators: this.filterStore.filterIndicators(level.indicators)\n                })).concat([{\n                    level: null,\n                    indicators: this.filterStore.filteredIndicators.filter(indicator => !indicator.levelpk)\n                }]);\n        }\n        return [];\n    }\n    \n    periodValues(indicator) {\n        if (this.filterStore.frequencyId == 1) {\n            return [];\n        }\n        if (this.filterStore.frequencyId && this.filterStore.programIsLoaded) {\n            let reportData = indicator.reportData[this.filterStore.reportType][this.filterStore.frequencyId];\n            if (reportData && reportData !== undefined) {\n                return this.filterStore.frequencyId == 2 ? reportData :\n                    reportData.slice(this.filterStore.startPeriod, this.filterStore.endPeriod + 1) || [];\n            } else {\n                let reportData = indicator.program.getIndicator(indicator.pk)\n                                    .reportData[this.filterStore.reportType][this.filterStore.frequencyId];\n                if (reportData && reportData !== undefined) {\n                    return this.filterstore.frequencyId == 2 ? reportData :\n                        reportData.slice(this.filterStore.startPeriod, this.filterStore.endPeriod + 1);\n                }\n            }\n        }\n        return [];\n    }\n    \n    @computed get reportWidth() {\n        return 8 + (this.levelColumn && 1) + 3 + (this.reportPeriods.length * (1 + (this.filterStore.isTVA && 2)));\n    }\n    \n};","\n/**\n * IPTT Constants:\n */\nconst BLANK_LABEL = '---------';\nconst BLANK_OPTION = {\n    value: null,\n    label: BLANK_LABEL\n};\nconst BLANK_TABLE_CELL = '';\n\n\nconst TVA = 1;\nconst TIMEPERIODS = 2;\n\nconst TIME_AWARE_FREQUENCIES = [3, 4, 5, 6, 7];\n\nexport { BLANK_OPTION, BLANK_LABEL, BLANK_TABLE_CELL, TVA, TIMEPERIODS, TIME_AWARE_FREQUENCIES };\n\nconst GROUP_BY_CHAIN = 1;\nconst GROUP_BY_LEVEL = 2;\n\nexport { GROUP_BY_CHAIN, GROUP_BY_LEVEL };\n\nconst _gettext = (typeof gettext !== 'undefined') ?  gettext : (s) => s;\n\nfunction getPeriodLabels() {\n    return {\n        targetperiodLabels: {\n            1: _gettext(\"Life of Program (LoP) only\"),\n            3: _gettext(\"Annual\"),\n            2: _gettext(\"Midline and endline\"),\n            5: _gettext(\"Tri-annual\"),\n            4: _gettext(\"Semi-annual\"),\n            7: _gettext(\"Monthly\"),\n            6: _gettext(\"Quarterly\")\n        },\n        timeperiodLabels: {\n            3: _gettext(\"Years\"),\n            5: _gettext(\"Tri-annual periods\"),\n            4: _gettext(\"Semi-annual periods\"),\n            7: _gettext(\"Months\"),\n            6: _gettext(\"Quarters\")\n        }\n    };\n}\n\nexport {getPeriodLabels};\n\nexport const STATUS_CODES = {\n    NO_INDICATOR_IN_UPDATE: 1\n};","import React from 'react';\nimport { observer, inject, computed } from 'mobx-react';\nimport { when } from 'mobx';\nimport { SingleReactSelect, SingleSelect, DateSelect, GroupBySelect } from '../../../../components/selectWidgets';\n\n\n/**  false && <Selectors.PeriodSelect />}\n                { false && <Selectors.TimeFrameRadio />}\n                { false && <Selectors.StartDateSelect />}\n                { false && <Selectors.EndDateSelect />}\n                { false && filterStore.oldLevels === false &&\n                    <Selectors.GroupingSelect />*/\n/**\n * input-ready filtering single-select for Programs available to user in IPTT Report\n * uses SingleSelect in js/components/selectWidgets\n */\n\nconst ProgramSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <SingleReactSelect\n                label={ gettext('Program') }\n                options={ filterStore.programOptions }\n                value={ filterStore.selectedProgramOption }\n                update={ selected => { filterStore.programId = selected.value } }\n            />\n        );\n    })\n);\n\n/**\n * input-ready filtering single-select for Frequencies available for selected program in IPTT Report\n * uses SingleSelect in js/components/selectWidgets\n */\n\nconst FrequencySelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return (\n            <SingleReactSelect\n                label={\n                    filterStore.isTVA ?\n                        gettext('Target periods') :\n                        gettext('Time periods')\n                }\n                options={ filterStore.frequencyOptions }\n                value={ filterStore.selectedFrequencyOption }\n                update={ selected => { filterStore.frequencyId = selected.value } }\n            />\n        );\n    })\n);\n\n/**\n * Show All radio / Most Recent radio / number of Most Recent periods input combo component\n * For selecting start and end of IPTT report\n * controlled component - logic to update date selects in filterStore model (../models)\n */\n@inject('filterStore')\n@observer\nclass TimeframeRadio extends React.Component {\n    constructor(props) {\n        super(props);\n        this.mostRecentInputRef = React.createRef();\n        this.state = {\n            focus: false,\n            mostRecentValue: props.filterStore.mostRecent || '',\n            revert: false,\n        };\n    }\n\n    setShowAll = () => {\n        this.setState({\n            focus: false,\n            revert: false,\n            });\n        this.props.filterStore.showAll = true;\n    }\n\n    checkMostRecent = () => {\n        this.mostRecentInputRef.current.focus();\n    }\n\n    handleChange = (e) => {\n        this.setState({mostRecentValue: e.target.value});\n    }\n\n    handleBlur = (e) => {\n        if (!this.state.revert && this.state.mostRecentValue !== '') {\n            this.props.filterStore.mostRecent = this.state.mostRecentValue;\n            this.setState({\n                focus: false,\n                revert: false,\n                mostRecentValue: this.props.filterStore._mostRecentValue,\n            });\n        } else if (this.state.revert) {\n            this.setShowAll();\n        } else {\n            this.setState({\n                focus: false\n            });\n        }\n    }\n\n    handleKeyDown = (e) => {\n        if (e.keyCode === 13) {\n            e.target.blur();\n        } else if (e.keyCode === 27) {\n            this.setState({revert: true}, \n            () => {this.mostRecentInputRef.current.blur();});\n        }\n    }\n\n    handleFocus = (e) => {\n        let newState = {\n            focus: true,\n            mostRecentValue: (this.props.filterStore._mostRecentValue || '')\n            };\n        if (!this.mostRecentValue) {\n            newState.mostRecentValue = '';\n        }\n        this.setState(newState);\n    }\n\n    get mostRecentValue() {\n        if (this.state.focus) {\n            return this.state.mostRecentValue;\n        } else {\n            return this.props.filterStore.mostRecent || '';\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"form-row mb-3\">\n                <div className=\"col-sm-4\">\n                    <div className=\"form-check form-check-inline pt-1\">\n                        <span className=\"form-check-input\">\n                            <input type=\"radio\"\n                                   checked={ !this.props.filterStore.periodsDisabled && !this.state.focus && this.props.filterStore.showAll }\n                                   disabled={ this.props.filterStore.periodsDisabled }\n                                   onChange={ this.setShowAll }\n                                   />\n                        </span>\n                        <label onClick={ this.setShowAll } \n                               className=\"form-check-label\">\n                            {\n                                /* # Translators: option to show all periods for the report */\n                                gettext('Show all')\n                            }\n                        </label>\n                    </div>\n                </div>\n                <div className=\"col-sm-4 p-0\">\n                    <div className=\"form-check form-check-inline pt-1\">\n                        <span className=\"form-check-input\">\n                            <input type=\"radio\"\n                                   checked={ !this.props.filterStore.periodsDisabled && (this.state.focus || this.props.filterStore.mostRecent) }\n                                   disabled={ this.props.filterStore.periodsDisabled }\n                                   onChange={ this.checkMostRecent }\n                                   />\n                        </span>\n                        <label onClick={ this.checkMostRecent }\n                               className=\"form-check-label\">\n                            {\n                                /* # Translators: option to show a number of recent periods for the report */\n                                gettext('Most recent')\n                            }\n                        </label>\n                    </div>\n                </div>\n                <div className=\"col-sm-4\">\n                    <input type=\"number\" className=\"form-control\"\n                           value={ !this.props.filterStore.periodsDisabled && this.mostRecentValue }\n                           ref={ this.mostRecentInputRef }\n                           disabled={ this.props.filterStore.periodsDisabled }\n                           onChange={ this.handleChange }\n                           onFocus={ this.handleFocus }\n                           onBlur={ this.handleBlur }\n                           onKeyDown={ this.handleKeyDown }\n                           />\n                </div>\n           </div>\n        );\n    }\n}\n\n/**\n * non input-ready dropdown for periods available for Start of IPTT Report select\n * composes DateSelect in components/selectWidgets\n */\nconst StartDateSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <DateSelect\n                    label={\n                        /* # Translators: menu for selecting the start date for a report */\n                        gettext('Start')\n                    }\n                    disabled={ filterStore.periodsDisabled }\n                    value={ filterStore.startPeriod || '' }\n                    update={ e => {filterStore.startPeriod = e.target.value;} }\n                    options={ filterStore.startOptions }\n                />\n    })\n);\n\n/**\n * non input-ready dropdown for periods available for End of IPTT Report select\n * composes DateSelect in components/selectWidgets\n */\nconst EndDateSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <DateSelect\n                    label={\n                        /* # Translators: menu for selecting the end date for a report */\n                        gettext('End')\n                    }\n                    disabled={ filterStore.periodsDisabled }\n                    value={ filterStore.endPeriod || '' }\n                    update={ e => {filterStore.endPeriod = e.target.value;} }\n                    options={ filterStore.endOptions }\n                />\n    })\n);\n\n/**\n * single select with non dynamic options (dynamic labeling based on program's name for tier 2)\n * selects \"grouping\" or \"chaining\" based display of indicators in report and filter dropdowns\n */\nconst GroupingSelect = inject('filterStore')(\n    observer(({ filterStore }) => {\n        return <GroupBySelect\n                    chainLabel={ filterStore.resultChainFilterLabel }\n                    disabled={ filterStore.groupByDisabled }\n                    value={ filterStore.groupBy }\n                    update={ e => { filterStore.groupBy = e.target.value;} }\n                />\n    })\n);\n\n\nexport { ProgramSelect, FrequencySelect, TimeframeRadio, StartDateSelect, EndDateSelect, GroupingSelect };","/**\n * API for IPTT report - handles updating IPTT report data when a new program/frequency is selected\n */\n\n\nexport default class ReportAPI {\n    constructor(ajaxURL) {\n        this.url = ajaxURL;\n    }\n    \n    callForReportData(reportType, programId, frequency) {\n        let params = {\n            programId: programId,\n            frequency: frequency,\n            reportType: reportType\n        };\n        return $.get(this.url, params);\n    }\n    \n    callForIndicatorData(reportType, programId, frequency, indicatorId) {\n        let params = {\n            programId: programId,\n            reportType: reportType,\n            frequency: frequency,\n            indicatorId: indicatorId,\n            updateIndicator: '1'\n        }\n        return $.get(this.url, params);\n    }\n\n}"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AADA;AAEA;AAAA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAOA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAHA;AAIA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AAAA;AAEA;;;;AAlBA;AACA;AADA;AAsBA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AA/BA;AAiCA;AACA;AACA;AAnCA;AAAA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;AAyBA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAAA;AAWA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;;;;AAIA;;;AAOA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAFA;AAMA;;;;;;;;;;;;;;;;;AACA;;;;;;AACA;AACA;AACA;;;;AAJA;AAOA;;;;;AASA;AAAA;AACA;AADA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;;AAtCA;AAyCA;;;AAKA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAFA;AACA;AAMA;;;AAQA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAzBA;AA2BA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;;;;;;AAGA;;;AAGA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AA+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3CA;AACA;AAAA;AAAA;AACA;AACA;;;AAKA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AACA;;;AAlBA;AACA;AAAA;AAAA;AACA;;;;;;AAuCA;;;AA2BA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAkBA;AACA;AACA;AACA;AAAA;AACA;AACA;AAvBA;AAyBA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AA/DA;AAiEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AA/EA;AAiFA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AA7FA;AA+FA;AACA;AACA;AAjGA;AAmGA;AACA;AACA;AArGA;AAuGA;AAAA;AAAA;AACA;AACA;AAzGA;AA2GA;AAAA;AAAA;AACA;AACA;AA7GA;AA+GA;AACA;AACA;AAjHA;AAmHA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAzHA;AA2HA;AACA;AACA;AA7HA;AA+HA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AArJA;AAuJA;AACA;AACA;AACA;AA1JA;AA4JA;AACA;AACA;AACA;AA/JA;AAoMA;AAAA;AACA;AArMA;AAsMA;AAAA;AACA;AAvMA;AAwMA;AAAA;AACA;AAzMA;AA0MA;AAAA;AACA;AA3MA;AA4MA;AAAA;AACA;AA7MA;AA8MA;AAAA;AACA;AA9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;AAgJA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAcA;AACA;AACA;;;;AA5OA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;;;AACA;;AAGA;;;;;;;AACA;;AAGA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AAkKA;AAsDA;AACA;AAAA;AAEA;;;AAIA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAaA;AACA;AACA;AACA;AACA;AAjBA;AAsBA;AACA;AACA;AAxBA;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AArCA;AA0CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AA5CA;AA8CA;AACA;AACA;AAhDA;AAkDA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AA7DA;AA+DA;AAAA;AAAA;AACA;AACA;AAjEA;AAmEA;AAGA;AACA;AAvEA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;;;;;;;AAgBA;AACA;AACA;AAEA;;;;;;;AAhCA;;;;;AAAA;;AA4BA;;;;;;;AAgDA;AACA;AACA;AAAA;AACA;AAIA;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxpBA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAQA;AAAA;AAAA;AACA;AACA;AAVA;AAWA;AACA;AACA;AAbA;AAcA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAXA;AAaA;AACA;AA3BA;AACA;AACA;AAFA;AAFA;AAMA;AACA;;;AAsBA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAOA;AAAA;AACA;AAOA;AACA;AACA;AAAA;AACA;AAOA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAGA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AACA;AASA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAxDA;AA6DA;AAGA;;;;AAtGA;AACA;AA0GA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AAEA;AACA;AACA;AAAA;AAAA;AAHA;AAMA;AACA;AAZA;AAAA;AACA;AADA;AAAA;AAAA;AAcA;AAGA;AACA;AACA;AAHA;AAIA;AAAA;AAEA;AACA;AAKA;AA5BA;AACA;AADA;AAAA;AACA;AAgCA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAGA;AAAA;AAAA;AAAA;AAEA;AACA;AAKA;;;;AA7BA;AACA;AAiCA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAIA;AAEA;AACA;AAFA;AAIA;AACA;AAVA;AAAA;AACA;AADA;AAAA;AAAA;AAYA;AAEA;AACA;AACA;AAFA;AAGA;AAAA;AAIA;AArBA;AACA;AADA;AAAA;AA2BA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AANA;AAAA;AACA;AADA;AAAA;AAAA;AAQA;AAEA;AACA;AACA;AAFA;AAGA;AAAA;AAIA;AAjBA;AACA;AADA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AADA;AAEA;AAAA;AAIA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AADA;AAEA;AAAA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AADA;AAOA;AACA;AAEA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAOA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAKA;AACA;AACA;AACA;AAFA;AADA;AASA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAEA;AACA;AACA;AAEA;AAAA;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AAGA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AALA;AAUA;AAGA;;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAFA;AADA;AAQA;AACA;AAGA;;;;;AAGA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAjBA;AAmBA;AACA;AAAA;AACA;AAAA;AADA;AAAA;AAGA;AAAA;AAEA;AACA;AAHA;AAAA;AAKA;AAAA;AAEA;AAFA;AAAA;AATA;AACA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AANA;AAWA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AALA;AAQA;;;;;;;;;;;;AC5MA;AAAA;AAAA;;;AAIA;AAEA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;;;;;;AAKA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAOA;AAVA;AAYA;AAGA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAIA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAIA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;AAIA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAPA;AASA;;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAMA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AAUA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;AAmBA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AA8DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAvEA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;;;;AAgFA;;;AAGA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;;;AASA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;;AAWA;;;;;;;AAOA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAyGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAiLA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;AAsOA;AAAA;AACA;AADA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAFA;AAKA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAFA;AAKA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;;;AAMA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AA3zBA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AAEA;;;;;;;AAeA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAgBA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAaA;AACA;AACA;;;AAEA;AACA;AACA;;;AAsCA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAGA;;;AAVA;AACA;AAGA;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAiBA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;;;AA2BA;AACA;AAAA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAQA;AACA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAAA;AAHA;AAAA;AAUA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAJA;AAKA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;;AAWA;AACA;AACA;AAQA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;;;AAgFA;AACA;AACA;;;;AA1yBA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AACA;;;;;AAAA;;AAsBA;;;;;;;AAwpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;;;;AAmJA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAGA;AACA;;AAEA;;;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACv3BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAHA;AAIA;AAAA;AAKA;AACA;AACA;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AADA;AAGA;AACA;AAKA;AACA;AAAA;AACA;AADA;AADA;AAQA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAHA;AAOA;AACA;AAAA;AACA;AAAA;AAFA;AAOA;AACA;AAEA;AACA;AACA;AAAA;AAKA;AACA;AACA;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAaA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAIA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AANA;AASA;AAAA;AAAA;AACA;AACA;AADA;AAEA;AAAA;AAKA;AAGA;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AAEA;AAGA;;;AAGA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AA0CA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AALA;AAAA;AAAA;AACA;AAKA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AAAA;AAEA;AAEA;AACA;AA5DA;AAkFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AA9IA;AAoJA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AA/JA;AAiKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAvKA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AARA;AAeA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AARA;AAeA;AAEA;AACA;AACA;AACA;AACA;;;AAuGA;AACA;AACA;;;AAwBA;AACA;AAKA;;;AAEA;AAAA;AACA;AAAA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAHA;AAKA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AAEA;AACA;AAHA;AAIA;AACA;AAAA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;;;;AA1HA;;;;;;;;;;;;;ACzJA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AADA;AAKA;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AACA;AAAA;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAMA;AACA;AACA;AACA;AAFA;AADA;AASA;AAGA;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAFA;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAIA;AAAA;AACA;AAAA;AAMA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;;;AAyDA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;;;AA3EA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAAA;AAIA;AACA;AAAA;AAAA;AAFA;AAIA;AACA;AAAA;AACA;;;AAuBA;AACA;AACA;;;;AA/EA;AALA;AAsFA;;;;;;;;;;;;AC3FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AACA;AACA;AACA;AAFA;AAIA;AAGA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAVA;AAkBA;AACA;AACA;AAEA;AACA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AAGA;;;;;;;AAMA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AAGA;;;;;AAKA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAAA;AAAA;AARA;AAWA;AAGA;;;;;;AAOA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAWA;AACA;AACA;AAFA;AACA;AAGA;AACA;AACA;AAjBA;AAmBA;AACA;AACA;AArBA;AAuBA;AAAA;AAAA;AACA;AACA;AAzBA;AA2BA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AA1CA;AA4CA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAnDA;AAqDA;AACA;AACA;AAFA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AA5DA;AACA;AACA;AACA;AACA;AAHA;AAHA;AAQA;AACA;;;AA8DA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AADA;AAGA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AADA;AAGA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAYA;;;AA5DA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAtEA;AA+HA;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AARA;AAUA;AAGA;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AARA;AAUA;AAGA;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAMA;;;;;;;;;;;;;;;;;;;;;AC5OA;;;AAKA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;;;;;;;;;;A","sourceRoot":""}